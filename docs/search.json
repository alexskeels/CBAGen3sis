[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Center for Biodiversity Analysis: Gen3sis Workshop 2024",
    "section": "",
    "text": "Program"
  },
  {
    "objectID": "index.html#day-1",
    "href": "index.html#day-1",
    "title": "Center for Biodiversity Analysis: Gen3sis Workshop 2024",
    "section": "Day 1",
    "text": "Day 1\n\n\n\n\n\n\n\nTime\nEvent\n\n\n\n\n09:00 - 09:50\nüëã‚òï Welcome (Platypus Room) - Coffee, introductions, and overview of Gen3sis workshop\n\n\n09:50 - 11:00\nüéì Lecture 1 - Oskar Hagen (Eucalyptus Room): From German Romanticism to modern computational biodiversity models\n\n\n11:00 - 11:15\n‚òï Coffee Break\n\n\n11:15 - 12:00\nüõ†Ô∏è Practical 1 - Gettin‚Äô Started: Installation and Set Up\n\n\n12:00 - 12:30\nüõ†Ô∏è Practical 2 - Configure Skating: Gen3sis Config Basics\n\n\n12:30 - 13:30\nüçΩÔ∏è Lunch Break\n\n\n13:30 - 15:30\nüõ†Ô∏è Practical 2 - Configure Skating: Gen3sis Config Basics\n\n\n15:30 - 15:45\n‚òï Coffee Break\n\n\n15:45 - 16:30\nüèùÔ∏è Practical 3 - Island Hopping: Explore a model island system\n\n\n16:30 - 17:00\n‚ùì Questions / Wrap up Day 1"
  },
  {
    "objectID": "index.html#day-2",
    "href": "index.html#day-2",
    "title": "Center for Biodiversity Analysis: Gen3sis Workshop 2024",
    "section": "Day 2",
    "text": "Day 2\n\n\n\n\n\n\n\nTime\nEvent\n\n\n\n\n09:00 - 10:00\nüéì Lecture 2 - Alex and Oskar (Platypus Room): Inference from simulated biodiversity data\n\n\n10:00 - 10:30\nüåç Practical 4.1 - Silicodiversity: Gen3sis outputs and patterns\n\n\n10:30 - 10:45\n‚òï Coffee Break\n\n\n10:45 - 12:30\nüåç Practical 4.2 - Silicodiversity: Gen3sis outputs and patterns\n\n\n12:30 - 13:30\nüçΩÔ∏è Lunch Break\n\n\n13:30 - 14:15\nüéì Lecture 3 - Tristan Salles (Platypus Room): Paleoenvironmental models and data\n\n\n14:15 - 14:45\nüí¨ Discussion\n\n\n14:45 - 15:00\n‚òï Coffee Break\n\n\n15:00 - 16:30\nüåç Practical 5 - Creating Worlds: Modifying landscapes as inputs for Gen3sis\n\n\n16:30 - 17:00\n‚ùì Questions / Wrap up Day 2"
  },
  {
    "objectID": "index.html#day-3",
    "href": "index.html#day-3",
    "title": "Center for Biodiversity Analysis: Gen3sis Workshop 2024",
    "section": "Day 3",
    "text": "Day 3\n\n\n\n\n\n\n\nTime\nEvent\n\n\n\n\n09:00 - 10:00\nüéì Lecture 4 - Alex and Oskar: Designing simulation experiments with Gen3sis\n\n\n10:00 - 10:30\nü§ùÔ∏è Practical 6 - Sandbox: Implementing models in Gen3sis\n\n\n10:30 - 10:45\n‚òï Coffee Break\n\n\n10:45 - 12:30\nü§ùÔ∏è Practical 6 - Sandbox: Implementing models in Gen3sis\n\n\n12:30 - 13:30\nüçΩÔ∏è Lunch Break\n\n\n13:30 - 14:45\nü§ùÔ∏è Wrapping up Sandbox\n\n\n14:45 - 15:00\n‚òï Coffee Break\n\n\n15:00 - 16:00\nüé§ Presenting Sandbox models / Wrap up Day 3\n\n\n16:00 - 16:10\nüîÑ Feedback session - Gathering final thoughts and suggestions\n\n\n16:10\nüçª Pub!"
  },
  {
    "objectID": "Day1_Prac1_setup.html#download-workshop-files-github-repository",
    "href": "Day1_Prac1_setup.html#download-workshop-files-github-repository",
    "title": "1¬† üçç Gettin‚Äô Started",
    "section": "Download workshop files Github Repository",
    "text": "Download workshop files Github Repository\nFirst thing is to download all of the data needed from github and set up our workspace.\n\nGo to https://github.com/alexskeels/CBAGen3sis and download the repository as follows:\n\nPut it somewhere on your machine that you can readily access\nUnzip the folder\nOpen up RStudio\nSet the working directory to this folder using here package.\n\nif (!require(\"here\")) {\n  install.packages(\"here\")\n}\nlibrary(here)\n#setwd(file.path(\"WHERE/YOU/UNZIPPED\",\"CBAGen3sis.github.io\"))\n\n\nThis will make sure all the paths in the code are relative to the root, and things should work like magic.\nNow you should be able to follow along, copying the code from this Quarto document into your console. The alternative option is to open the RProject file ‚ÄúCBA_Gen3sis_Workshop_2024.Rproj‚Äù and work directly within this project."
  },
  {
    "objectID": "Day1_Prac1_setup.html#install-packages",
    "href": "Day1_Prac1_setup.html#install-packages",
    "title": "1¬† üçç Gettin‚Äô Started",
    "section": "Install Packages",
    "text": "Install Packages\nToday we‚Äôll install the stable version of the package directly from CRAN as follows.\n\n# install the package\ninstall.packages(\"gen3sis\")\n\n# check the package version, we are on 1.5.11\npackageVersion(\"gen3sis\")\n\nYou could also install the most recent version of the package from GitHub using devtools. But hold off on this today so we‚Äôre all working with the same version.\n\n#install.packages(\"devtools\")\n#devtools::install_github(repo = \"project-gen3sis/R-package\", dependencies = TRUE)\n#packageVersion(\"gen3sis\")\n\nload gen3sis\nNow, lets source our support functions, to load some of the functions we‚Äôll be going throughout the workshop. The first one is just a convenient way of installing packages if they are not already installed.\n\nsource(\"support.R\")\n# packages to load and install if necessary\nload_install_pkgs(c(\"terra\", \"raster\", \"here\", \"ape\", \"phytools\", \"picante\", \"caret\"))"
  },
  {
    "objectID": "Day1_Prac1_setup.html#access-data",
    "href": "Day1_Prac1_setup.html#access-data",
    "title": "1¬† üçç Gettin‚Äô Started",
    "section": "Access Data",
    "text": "Access Data\nAll the data for the workshop is stored in the ‚Äòdata‚Äô folder, for your convenience, we set the paths to the variable data_dir (and) others) on our support.R file.\nIn this folder we include a paleoenvironmental reconstruction of South American temperature and aridity at a coarse spatial resolution of 2 degrees, and at a temporal resolution of 1 million years. This is a very rough temporal resolution but should do for our tutorial. Load it in and investigate some of it‚Äôs features.\n\n# read the R data file\nlandscape &lt;- readRDS(file.path(\"data\",\"landscapes\", \"SouthAmerica\", \"landscapes.rds\"))\n\n# class\nclass(landscape)\n\n[1] \"list\"\n\n# names\nnames(landscape)\n\n[1] \"temp\" \"arid\" \"area\"\n\n# dimensions\ndim(landscape$temp)\n\n[1] 1476   68\n\n# take a look at first elements\nlandscape$temp[1:10, 1:10]\n\n     x  y        1        2        3        4        5        6        7\n1  -94 12       NA       NA       NA       NA       NA       NA       NA\n2  -92 12       NA       NA       NA       NA       NA       NA       NA\n3  -90 12       NA       NA       NA       NA       NA       NA       NA\n4  -88 12       NA       NA       NA       NA       NA       NA 27.97588\n5  -86 12 22.76293 28.90419 28.61839 28.47647 28.00591 27.22872 26.96520\n6  -84 12 23.40779 29.34289 28.68802 28.96432 28.39244 27.69988 27.31383\n7  -82 12       NA       NA       NA       NA       NA       NA       NA\n8  -80 12       NA       NA       NA       NA       NA       NA       NA\n9  -78 12       NA       NA       NA       NA       NA       NA       NA\n10 -76 12       NA       NA       NA       NA       NA       NA       NA\n          8\n1        NA\n2        NA\n3        NA\n4  27.87671\n5  27.05735\n6  27.95244\n7        NA\n8        NA\n9        NA\n10       NA\n\n# column names\ncolnames(landscape$temp)\n\n [1] \"x\"  \"y\"  \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\"\n[16] \"14\" \"15\" \"16\" \"17\" \"18\" \"19\" \"20\" \"21\" \"22\" \"23\" \"24\" \"25\" \"26\" \"27\" \"28\"\n[31] \"29\" \"30\" \"31\" \"32\" \"33\" \"34\" \"35\" \"36\" \"37\" \"38\" \"39\" \"40\" \"41\" \"42\" \"43\"\n[46] \"44\" \"45\" \"46\" \"47\" \"48\" \"49\" \"50\" \"51\" \"52\" \"53\" \"54\" \"55\" \"56\" \"57\" \"58\"\n[61] \"59\" \"60\" \"61\" \"62\" \"63\" \"64\" \"65\" \"66\"\n\n\nCoolies. We can use different spatial R packages to play with our data, and later on, with our simulated output.\n\n# Present Day South America\nSA_1 &lt;- rast(landscape$temp[ ,c(\"x\", \"y\", \"1\")])\nSA_65 &lt;- rast(landscape$temp[,c(\"x\", \"y\", \"65\")])\n\n# plot present day\nplot(SA_1)\n\n\n\n\n\n# plot 65 Million years ago\nplot(SA_65)\n\n\n\n\nLets overlay the maps to get an idea of how much South America has changed since the dinosaurs went extinct.\n\n# overlay\nplot(SA_65, col=rgb(1,0,0))\nplot(SA_1, col=rgb(0,0,1,0.5,1), add=T)"
  },
  {
    "objectID": "Day1_Prac1_setup.html#access-configs",
    "href": "Day1_Prac1_setup.html#access-configs",
    "title": "1¬† üçç Gettin‚Äô Started",
    "section": "Access Configs",
    "text": "Access Configs\nLoad in a config file containing the rules and parameters of a single simulation. We‚Äôll get into what this all means in the next chapter.\n\nconfig &lt;- create_input_config(config_file = file.path(\"configs\", \"config_southamerica_Day1Prac1.R\"))\nnames(config$gen3sis)\n\n[1] \"general\"        \"initialization\" \"dispersal\"      \"speciation\"    \n[5] \"mutation\"       \"ecology\"       \n\nnames(config$gen3sis$general)\n\n[1] \"random_seed\"                      \"start_time\"                      \n[3] \"end_time\"                         \"max_number_of_species\"           \n[5] \"max_number_of_coexisting_species\" \"end_of_timestep_observer\"        \n[7] \"trait_names\"                      \"environmental_ranges\"            \n[9] \"verbose\""
  },
  {
    "objectID": "Day1_Prac1_setup.html#run-a-single-simulation",
    "href": "Day1_Prac1_setup.html#run-a-single-simulation",
    "title": "1¬† üçç Gettin‚Äô Started",
    "section": "Run a Single Simulation",
    "text": "Run a Single Simulation\nNow time to run a simulation in South America. We‚Äôll just run from 20 million years ago to the present-day at 1 million year intervals so it runs quick enough to finish in a couple of minutes. Note the output as it runs. Think about what its printing.\n\nsim &lt;- run_simulation(config = file.path(\"configs\", \"config_southamerica_Day1Prac1.R\"), \n               landscape = file.path(data_dir,\"landscapes\", \"SouthAmerica\"),\n               output_directory = \"output/SouthAmerica\",\n               verbose=1)\n\nNow read in some of the outputs.\n\n# read phylogeny\nphy &lt;- read.nexus(file.path(\"output\", \"SouthAmerica\", \"config_southamerica_Day1Prac1\", \"phy.nex\" ))\n\n# plot phylogeny\nplot(phy, cex=0.1, type=\"fan\")\n\n\n\n\nIf you‚Äôve made it this far, great! You‚Äôre equipped with the tools, now we‚Äôre ready to explore how Gen3sis works in more detail."
  },
  {
    "objectID": "Day1_Prac2_basics.html#general",
    "href": "Day1_Prac2_basics.html#general",
    "title": "2¬† ‚õ∏Ô∏è Configure Skating",
    "section": "General",
    "text": "General\nThe first element, ‚Äògeneral‚Äô, sets up some important global parameters of the model\n\nconfig$gen3sis$general\n\n$random_seed\n[1] 6\n\n$start_time\n[1] 20\n\n$end_time\n[1] NA\n\n$max_number_of_species\n[1] 50000\n\n$max_number_of_coexisting_species\n[1] 10000\n\n$end_of_timestep_observer\nfunction (data, vars, config) \n{\n    save_species()\n    plot_richness(data$all_species, data$landscape)\n}\n&lt;environment: 0x127058d68&gt;\n\n$trait_names\n[1] \"temp\"         \"temp_breadth\" \"dispersal\"   \n\n$environmental_ranges\n$environmental_ranges$temp\n[1] -45  55\n\n$environmental_ranges$area\n[1]  2361.5 12923.4\n\n$environmental_ranges$arid\n[1] 1.0 0.5\n\n\n$verbose\n[1] FALSE\n\n\nThe random seed determines the starting point for random number generators in R. Because the simulations have stochastic processes, to reproduce a result, we need to have the same random seed, so by fixing it in a simulation, we can ensure we will get the exact same results next time we run the sim. Let‚Äôs change the seed to 777.\n\nconfig$gen3sis$general$random_seed\n\n[1] 6\n\nconfig$gen3sis$general$random_seed &lt;- 777\n\nThe start time is the time-step of the landscape file which the simulation will start at. We saw in the previous chapter that the South American landscape file had 65 time-steps, but we actually only started our simulation at time-step 20, or 20 time-steps before the final one. Each time-step in the landscape is 1 million years apart, so the timestep 20 is 20 million years ago. However, if the landscape units were in 100 thousand years, then time-step 20 would be 2 million years ago. Let‚Äôs run the next simulation from an older timepoint, lets say the start of the Oligocene, 34 Ma.\n\nconfig$gen3sis$general$start_time\n\n[1] 20\n\nconfig$gen3sis$general$start_time &lt;- 34\n\nOur simulation ran from 20 Ma to the present-day. However, we may wish for the simulation to finish before the present-day, for example just the Oligocene period 34Ma - 23Ma. To do this we can change the ‚Äòend_time‚Äô. When left as NA, the simulation will run to the final time-step. So let‚Äôs change that to 23 Ma.\n\nconfig$gen3sis$general$end_time\n\n[1] NA\n\nconfig$gen3sis$general$end_time &lt;- 23\n\nOther general settings include setting the maximum number of species in simulation, and in each grid cell before the simulation terminates (max_number_of_species, max_number_of_coexisting_species) which is a good way of aborting simulations before they get unwieldy, the names of the traits that each species will have in the simulation (trait_names), and the range of the environmental data (environmental_ranges). We‚Äôll these as is for now.\n\nconfig$gen3sis$general$max_number_of_species\n\n[1] 50000\n\nconfig$gen3sis$general$max_number_of_coexisting_species\n\n[1] 10000\n\nconfig$gen3sis$general$trait_names\n\n[1] \"temp\"         \"temp_breadth\" \"dispersal\"   \n\nconfig$gen3sis$general$environmental_ranges\n\n$temp\n[1] -45  55\n\n$area\n[1]  2361.5 12923.4\n\n$arid\n[1] 1.0 0.5\n\n\nLast but not least in the general setting is the oberserver function. At each time step in the simulation, users have the option to save different outputs and make different plots. The species object contains a list, where each element is a species. The species has information on the occupancy, abundance, and trait values of populations of that species in all inhabited grid cells. The phylogeny object contains information on the relatedness of all species to each other.\nMost of the biodiversity infromation we simulate is contained in species objects and phylogeny objects so we will save these at each timestep. We will also plot species richness as a way of visualizing how the simulation proceeds.\n\nconfig$gen3sis$general$end_of_timestep_observer = function(data, vars, config){\n    save_species()\n    save_phylogeny()\n  \n  # plotting function example:\n    plot_richness(data$all_species, data$landscape)\n}"
  },
  {
    "objectID": "Day1_Prac2_basics.html#initialization",
    "href": "Day1_Prac2_basics.html#initialization",
    "title": "2¬† ‚õ∏Ô∏è Configure Skating",
    "section": "Initialization",
    "text": "Initialization\nInitialization lets us define the number, abundance, location, and traits of the ancestral species. This is what you start the simulation with. You may want to start with a single species, so the simulation follows the diversification of single monophyletic radiation. Alternatively, you may seed the landscape with many species and this is also possible. Each species must be given the locations in which they will occur, in the form of characters matching the grid cell identifiers, and values for the traits we named in the general settings.\n\nconfig$gen3sis$initialization\n\n$initial_abundance\n[1] 1\n\n$create_ancestor_species\nfunction (landscape, config) \n{\n    n_ancestors &lt;- 5\n    range &lt;- c(-95, -24, -68, 13)\n    co &lt;- landscape$coordinates\n    selection &lt;- co[, \"x\"] &gt;= range[1] & co[, \"x\"] &lt;= range[2] & \n        co[, \"y\"] &gt;= range[3] & co[, \"y\"] &lt;= range[4]\n    new_species &lt;- list()\n    for (i in 1:n_ancestors) {\n        initial_cells &lt;- rownames(co)[selection]\n        initial_cells &lt;- sample(initial_cells, 1)\n        new_species[[i]] &lt;- create_species(initial_cells, config)\n        new_species[[i]]$traits[, \"temp\"] &lt;- landscape$environment[initial_cells, \n            \"temp\"]\n        new_species[[i]]$traits[, \"temp_breadth\"] &lt;- 0.05\n        new_species[[i]]$traits[, \"dispersal\"] &lt;- 1\n    }\n    return(new_species)\n}\n&lt;environment: 0x127058d68&gt;\n\n\nIn this example, we are generating five species to begin. We first define a box from which we sample points to use to place the first species on the landscape. We randomly sample a single grid cell to place each initial species in. Next, we give each initial species values for the three traits. Here, we give the value for temp as the temperature value of the grid cell the species will occur in. We set a dispersal equal to 1. We repeat this 5 times, for 5 species. We can create more ancestor species by repeating this process in a loop , or we could manually create ancestral range by hand-selecting grid cells for the species to occur in."
  },
  {
    "objectID": "Day1_Prac2_basics.html#dispersal-migration",
    "href": "Day1_Prac2_basics.html#dispersal-migration",
    "title": "2¬† ‚õ∏Ô∏è Configure Skating",
    "section": "Dispersal (migration)",
    "text": "Dispersal (migration)\nHow species disperse across the landscape is determined by simulated migration events between habitable cells. The range and behaviour of these events is set by users and can be based on fixed values, draws from probability distributions, species trait values, or anything else thought up by users.\n\nconfig$gen3sis$dispersal\n\n$max_dispersal\n[1] Inf\n\n$get_dispersal_values\nfunction (n, species, landscape, config) \n{\n    values &lt;- rweibull(n, shape = 1.5, scale = 200)\n    return(values)\n}\n&lt;environment: 0x127058d68&gt;\n\n\nHere we set the maximum dispersal distance as infinty (e.g., no maximum), and we draw the dispersal values from a Weibull distribution with shape parameter = 1.5 and scale = 133. We can see what this distribution looks like by plotting a histogram.\n\nhist(rweibull(1000, 1.5, 133), main= \"Weibull Distribution 1\", xlab=\"Dispersal Distance (km)\")\n\n\n\n\nYou can see the dispersal kernel is skewed around the scale parameter (here scale =133), so most dispersal is over shorter distances but some dispersal will be over a longer distance. You can play with the parameters to change the dispersal kernel. These could be based on a trait of the species.\n\n#more skewed distribution\nhist(rweibull(1000, 0.5, 133), main= \"Weibull Distribution 2\", xlab=\"Dispersal Distance (km)\")\n\n\n\n\n\n#less skewed distribution\nhist(rweibull(1000, 3, 133), main= \"Weibull Distribution 2\", xlab=\"Dispersal Distance (km)\")"
  },
  {
    "objectID": "Day1_Prac2_basics.html#speciation-population-divergence",
    "href": "Day1_Prac2_basics.html#speciation-population-divergence",
    "title": "2¬† ‚õ∏Ô∏è Configure Skating",
    "section": "Speciation (population divergence)",
    "text": "Speciation (population divergence)\nIn the speciation function, we determine how populations diverge from one another and when they are sufficiently divergent to become new species. Populations that are geographically isolated (allopatric) diverge at each time step by the divergence factor and are considered new species when the accumulated divergence is greater than the divergence threshold. Divergence decreases when they come back into secondary contact at a rate of 1 and will coalesce into the same population once divergence is equal to 0.\n\nconfig$gen3sis$speciation\n\n$divergence_threshold\n[1] 2\n\n$get_divergence_factor\nfunction (species, cluster_indices, landscape, config) \n{\n    return(1)\n}\n&lt;environment: 0x127058d68&gt;\n\n\nIn this example, the get_divergence_funtion returns a value of 1 each timestep, so the divergence accumulates by a value of 1 at each time step and populations become new species when divergence is greater than the divergence threshold, here given a value of 2. So a new species can form if two populations has been isolated for two timesteps.\nWe can change either the amount of divergence required for speciation‚Ä¶\n\nconfig$gen3sis$speciation$divergence_threshold &lt;- 4\n\n‚Ä¶or the rate at which divergence accumulates.\n\nconfig$gen3sis$speciation$get_divergence_factor &lt;- function(species, cluster_indices, landscape, config) { return(2)}\n\nBoth of these will speed up the rate of speciation, given enough population fragmentation."
  },
  {
    "objectID": "Day1_Prac2_basics.html#mutation-trait-evolution",
    "href": "Day1_Prac2_basics.html#mutation-trait-evolution",
    "title": "2¬† ‚õ∏Ô∏è Configure Skating",
    "section": "Mutation (trait evolution)",
    "text": "Mutation (trait evolution)\nIn the evolution function, we determine how the species‚Äô traits change at each timestep and therefore how they evolve over time. In gen3sis, each species is comprised of separate populations in each inhabited grid cell, these populations form geographic clusters that are within dispersal distance of one another and could be considered to exchange individuals, and all geographic clusters together comprise the species.\nWe can evolve traits of each population independently. Alternatively, we could give all populations within a geographic cluster shared trait values and evolve traits at this level of organization, or again at the whole species level. At which level of biological organization you evolve traits will depend on your hypothesis and the system you are trying to represent.\nIn addition to mutating the traits of species, we might also want to homogenise traits of populations that are likely exchanging gene flow.\nThis example, highlights both homogenising traits and evolving traits.\n\nconfig$gen3sis$mutation\n\n$apply_evolution\nfunction (species, cluster_indices, landscape, config) \n{\n    trait_evolutionary_power &lt;- 0.001\n    traits &lt;- species[[\"traits\"]]\n    cells &lt;- rownames(traits)\n    for (cluster_index in unique(cluster_indices)) {\n        cells_cluster &lt;- cells[which(cluster_indices == cluster_index)]\n        mean_abd &lt;- mean(species$abundance[cells_cluster])\n        weight_abd &lt;- species$abundance[cells_cluster]/mean_abd\n        traits[cells_cluster, \"temp\"] &lt;- mean(traits[cells_cluster, \n            \"temp\"] * weight_abd)\n    }\n    mutation_deltas &lt;- rnorm(length(traits[, \"temp\"]), mean = 0, \n        sd = trait_evolutionary_power)\n    traits[, \"temp\"] &lt;- traits[, \"temp\"] + mutation_deltas\n    return(traits)\n}\n&lt;environment: 0x127058d68&gt;\n\n\nHomogensation assigns each geographic cluster the avaerage trait value weighted by the abundance of each population. Here larger populations contribute more than smaller populations to the avergae.\nAfter homogenisation, the trait evolves by drawing random values from a normal distribution and adding these to the traits. A mean of 0 ensures that positive trait changes and negative trait changes are equally likely. The trait_evolutionary_power variable detemines the degree of trait evolution, with higher values leading to higher average trait changes each time step. This process of adding a random normal variable approximates a Brownian motion model of trait evolution."
  },
  {
    "objectID": "Day1_Prac2_basics.html#ecology-interactions",
    "href": "Day1_Prac2_basics.html#ecology-interactions",
    "title": "2¬† ‚õ∏Ô∏è Configure Skating",
    "section": "Ecology (interactions)",
    "text": "Ecology (interactions)\nEvery species present in a cell across the landscape has an abundance value representing the population size of the species in that location. The ecology function allows users to modify this abundance value based on environmental values, species interactions, or anything else relevant to the study. An abundance of 0 leads to the extinction of the species in that cell.\n\nconfig$gen3sis$ecology\n\n$apply_ecology\nfunction (abundance, traits, environment, config) \n{\n    env_diff &lt;- abs(traits[, \"temp\"] - environment[, \"temp\"])\n    abundance &lt;- env_diff &lt; traits[, \"temp_breadth\"]\n    return(abundance)\n}\n&lt;environment: 0x127058d68&gt;\n\n\nHere we use the temp trait (temperature niche position) and temp_breadth (temperature niche breadth) to determine whether a population can survive in cell. We get the absolute difference between the niche position and the temperature value in the grid cell. We then ask if this difference is more than the niche breadth. If it is larger, this means the value of the grid cell is outside the population‚Äôs niche breadth and it goes extinct in that grid cell. Extinction is indicated by giving the abundance a value of 0 or setting the abundance to FALSE as done here.\nOK, that gives you the basic overview of all the main components of the gen3sis model. We will now move on to running some simulations on an island case study. But before we do, we may want to save any changes we made to the config for later. To do this use the following code."
  },
  {
    "objectID": "Day1_Prac3_islands.html#dynamic-island-landscape",
    "href": "Day1_Prac3_islands.html#dynamic-island-landscape",
    "title": "3¬† üèùÔ∏è Island Hopping",
    "section": "Dynamic Island Landscape",
    "text": "Dynamic Island Landscape\n\n# load landscapes\nlc &lt;- readRDS(file.path(\"data\", \"landscapes\", \"islands\",\"landscapes.rds\"))\n\n# get names of landscape variables\nnames(lc)\n\n[1] \"elevation\" \"mean_temp\" \"min_temp\"  \"max_temp\"  \"patch\"    \n\n# get first time step\nfirst_step_pos &lt;- ncol(lc$mean_temp)\n\n# get first 10 sites of mean temperature for the 2 last time steps and the first (oldest) time step\nlc$mean_temp[100:110, c(1:4, first_step_pos)]\n\n       x    y        0        1      500\n100 39.5 58.5       NA       NA       NA\n101 40.5 58.5       NA       NA       NA\n102 41.5 58.5       NA       NA       NA\n103 42.5 58.5       NA       NA       NA\n104 43.5 58.5       NA       NA       NA\n105 44.5 58.5       NA       NA       NA\n106 45.5 58.5       NA       NA       NA\n107 46.5 58.5       NA       NA       NA\n108 47.5 58.5       NA 23.82152       NA\n109 48.5 58.5       NA 23.56207       NA\n110 49.5 58.5 24.89379 23.39746 24.85717\n\n\n\n# plot mean_temp for first and last time step\nplot(rast(lc$mean_temp[ ,c(1:3, first_step_pos)]))\n\n\n\n\nLook to see if there are any temporal trends in temperature or elevation.\n\npar(mfrow=c(1,2))\n# plot the change in mean tempereature through time\nmean_temperatures &lt;- colMeans(lc$mean_temp[, 3:ncol(lc$mean_temp)], na.rm=T)\nplot(seq(from=0, to = -5, by=-0.01),mean_temperatures ,  xlab=\"time (Ma)\", ylab=\"mean temperature\", type='l')\n\n# plot the change in mean elevation through time\nmean_elevation &lt;- colMeans(lc$elevation[, 3:ncol(lc$elevation)], na.rm=T)\nplot(seq(from=0, to = -5, by=-0.01), mean_elevation, xlab=\"time (Ma)\", ylab=\"mean elevation\", type='l')"
  },
  {
    "objectID": "Day1_Prac3_islands.html#model-1-config-time",
    "href": "Day1_Prac3_islands.html#model-1-config-time",
    "title": "3¬† üèùÔ∏è Island Hopping",
    "section": "Model 1: Config Time ‚è∞",
    "text": "Model 1: Config Time ‚è∞\nOpen the configs/config_islands_simple_Day1Prac3_M1.R script and have a look at it.\nOnce you are done, run a simulation. Note that we‚Äôre using a start time of 50 with 10-thousand-year time steps. So only the last 500 thousand years rather than the full 5 million. We will do this to keep things small.\n\n# run simulation\nsim_m1 &lt;- run_simulation(config = \"configs/config_islands_simple_Day1Prac3_M1.R\", \n                      landscape = \"data/landscapes/islands\", \n                      output_directory = \"output/islands\")\n\nInvestigate the output\n\nsim_m1 &lt;- readRDS(\"output/islands/config_islands_simple_Day1Prac3_M1/sgen3sis.rds\")\n\n\n# visualize the outputs\nplot_summary(sim_m1)\n\n\n\n\n\n# plot richness from summary in custom fashion, jsut to be familiar with the output\nna_mask &lt;- is.na(lc$elevation[,\"0\"])\nrich_m1 &lt;- sim_m1$summary$`richness-final`\nrich_m1[na_mask,3] &lt;- NA\nplot(rast(rich_m1, type=\"xyz\"), main=\"Richness\")\n\n\n\n\nPick a couple of random time points to look at specifically.\n\n# plot richness at time step 32 using saved data\nsps32 &lt;- readRDS(\"output/islands/config_islands_simple_Day1Prac3_M1/species/species_t_32.rds\")\nlc32 &lt;- readRDS(\"output/islands/config_islands_simple_Day1Prac3_M1/landscapes/landscape_t_32.rds\")\nplot_richness(sps32, lc32)\n\n\n\n# plot richness at time step 12 using saved data\nsps12 &lt;- readRDS(\"output/islands/config_islands_simple_Day1Prac3_M1/species/species_t_12.rds\")\nlc12 &lt;- readRDS(\"output/islands/config_islands_simple_Day1Prac3_M1/landscapes/landscape_t_12.rds\")\nplot_richness(sps12, lc12)\n\n\n\n\nNow look at the phylogeny\n\n# Now lets look at the Phylogeny\nlibrary(ape)\nphy_m1 &lt;- read.nexus(\"output/islands/config_islands_simple_Day1Prac3_M1/phy.nex\")\npar(mfrow=c(1,1))\nplot(phy_m1)"
  },
  {
    "objectID": "Day1_Prac3_islands.html#model-2-customise",
    "href": "Day1_Prac3_islands.html#model-2-customise",
    "title": "3¬† üèùÔ∏è Island Hopping",
    "section": "Model 2: Customise üíÖ",
    "text": "Model 2: Customise üíÖ\nLets start changing features of the config and compare the outputs to our first model.\n\n# load in config M1\nconf_m1 &lt;- create_input_config(\"configs/config_islands_simple_Day1Prac3_M1.R\")\n\n# load in config M2\nconf_m2 &lt;- create_input_config(\"configs/config_islands_simple_Day1Prac3_M2.R\")\n\n# previously, in M1, populations need 10 time steps to complete speciation\nconf_m1$gen3sis$speciation$divergence_threshold\n\n[1] 10\n\n# now populations only need 5 time steps to complete speciation\nconf_m2$gen3sis$speciation$divergence_threshold\n\n[1] 5\n\n#We have also change the observer function to save the presence/absence matrix for each time step.\n# see original config\nconf_m1$gen3sis$general$end_of_timestep_observer \n\nfunction (data, vars, config) \n{\n    plot_richness(data$all_species, data$landscape)\n    save_species()\n}\n&lt;environment: 0x14b667dc0&gt;\n\n# see modeified config\nconf_m2$gen3sis$general$end_of_timestep_observer \n\nfunction (data, vars, config) \n{\n    par(mfrow = c(2, 2), mar = c(2, 1, 1, 1))\n    for (sp_i in 1:4) {\n        plot_species_presence(data$all_species[[sp_i]], data$landscape)\n    }\n    par(mfrow = c(1, 1))\n    save_species()\n}\n&lt;environment: 0x10ba1e518&gt;\n\n\nRun M2!\n\n# run the new model\nsim_m2 &lt;- run_simulation(config=\"configs/config_islands_simple_Day1Prac3_M2.R\", landscape=\"data/landscapes/islands\", output_directory=\"output/islands\")\n\n\n# original dynamics\nplot_summary(sim_m1)\n\n\n\n# modified dynamics\nsim_m2 &lt;- readRDS(\"output/islands/config_islands_simple_Day1Prac3_M2/sgen3sis.rds\")\nplot_summary(sim_m2)"
  },
  {
    "objectID": "Day1_Prac3_islands.html#model-3-specialise",
    "href": "Day1_Prac3_islands.html#model-3-specialise",
    "title": "3¬† üèùÔ∏è Island Hopping",
    "section": "Model 3: SpecialiseüèùÔ∏è",
    "text": "Model 3: SpecialiseüèùÔ∏è\nThe differences between M1 and M2 are predictable. Speciation happens a bit faster in M2, and you end up with more species. Overall, however, the patterns of richness are pretty similar. This suggests that this change in the rate of speciation isn‚Äôt having a big impact on geographic variation in where species are forming (at least from a first glance). So let‚Äôs try a new model that has a few more tweaks to see a more measurable effect.\n\n#load in the config for model M3\nconf_m3 &lt;- create_input_config(\"configs/config_islands_simple_Day1Prac3_M3.R\")\n\n# take a look at the initialisation\nconf_m3$gen3sis$initialization\n\n$initial_abundance\n[1] 1\n\n$create_ancestor_species\nfunction (landscape, config) \n{\n    co &lt;- landscape$coordinates\n    pv &lt;- landscape$environment[, \"patch\"]\n    new_species &lt;- list()\n    manual_traits &lt;- list(dispersal = c(10, 7.5, 5, 2.5), temp_niche_width = c(0.5, \n        1, 2, 4))\n    for (sp_i in 1:4) {\n        new_species[[sp_i]] &lt;- create_species(names(pv[pv == \n            sp_i]), config)\n        new_species[[sp_i]]$traits[, \"dispersal\"] &lt;- manual_traits$dispersal[sp_i]\n        new_species[[sp_i]]$traits[, \"temp_niche_width\"] &lt;- manual_traits$temp_niche_width[sp_i]\n        new_species[[sp_i]]$traits[, \"start_island\"] &lt;- unique(landscape$environment[pv == \n            sp_i, \"patch\"])\n        new_species[[sp_i]]$traits[, \"temp_niche_centre\"] &lt;- mean(landscape$environment[pv == \n            sp_i, \"mean_temp\"])\n    }\n    return(new_species)\n}\n&lt;environment: 0x10aa460b8&gt;\n\n\nThere is a big differences here. In the initialization stage we give each species a different value of it‚Äôs dispersal ability and temperature width trait (niche breadth), and these are inversely related - high dispersing species have narrow niche breadths and low dispering species have wide niche breadths. This may create an interesting trade-off in dynamics of island colonization.\nRun the simulation\n\nsim_m3 &lt;- run_simulation(config=\"configs/config_islands_simple_Day1Prac3_M3.R\", \n                         landscape=\"data/landscapes/islands\",\n                         output_directory=\"output/islands\")\n\nNow compare the dynamics\n\nsim_m3 &lt;- readRDS(\"output/islands/config_islands_simple_Day1Prac3_M3/sgen3sis.rds\")\n\n# compare the plot summaries\nplot_summary(sim_m1)\n\n\n\nplot_summary(sim_m2)\n\n\n\nplot_summary(sim_m3)\n\n\n\n\n\nExercise\nFrom the small tweak to the divergence factor and the initial conditions, we can see more species being generated in M2 and M3 compared to M1.\nReview the M2 and M3 config files and try to understand what they‚Äôre doing.\n\nHow are the dynamics through time in M2 and M3 different to M1, and how are they similar?\nAre the original occupants of each island diversifying at the same pace? How could you test this?\nConsider how you might modify the configuration or apply it to a specific research question.\nDo you think all islands would have similar degrees of phylogenetic diversity or turnover?\n\nWe‚Äôll explore some of these questions tomorrow!"
  },
  {
    "objectID": "Day1_Prac3_islands.html#model-4-real",
    "href": "Day1_Prac3_islands.html#model-4-real",
    "title": "3¬† üèùÔ∏è Island Hopping",
    "section": "Model 4: RealüëÄ",
    "text": "Model 4: RealüëÄ\nIf you‚Äôve managed to get through all of this, run M4 config and using what you‚Äôve learned, plot some of the outputs. What has changed about this config?\n\nsim_m4 &lt;- run_simulation(config=\"configs/config_islands_simple_Day1Prac3_M4.R\", landscape=\"data/landscapes/islands\", output_directory=\"output/islands\")"
  },
  {
    "objectID": "Day2_Prac4_outputs.html#exploring-outputs",
    "href": "Day2_Prac4_outputs.html#exploring-outputs",
    "title": "4¬† üñ•Ô∏è Silicodiversity",
    "section": "Exploring outputs",
    "text": "Exploring outputs\nIn this practical we will explore the outputs from gen3sis using the island simulations we ran yesterday. We will learn how to use this data with common R packages for phylogenetic comparative methods, community phylogenetics, biogeography and much more.\nThe goal for today will be to produce:\n\nA map of Species Richness from the simulation summary object\nA plot of Lineages Through Time from the phylogeny\nPlot of species trait values on a phylogenetic tree, by linking the species objects to the phylogeny\nMaps of Phylogenetic Diversity by linking species objects to the landscape and phylogeny\n\nFirst, let‚Äôs make sure we have the necessary packages loaded\n\nrequire(gen3sis)\nrequire(terra)\nrequire(ape)\nrequire(phytools)\nrequire(picante)\nrequire(here)\nsetwd(here())\n\n\nSimulation summary object (sgen3sis.rds)\nThe first object we will look at today is the sgenesis.rds file. This file contains a summary of the simulation. Which we can plot (as we did yesterday) with the plot_summary function. This is the same object, that you would have in memory by running a simulation with run_simulation.\n\noutput_dir &lt;- \"output/islands\" \n\nsim &lt;- readRDS(file.path(output_dir, \"config_islands_simple_Day1Prac3_M3/sgen3sis.rds\")) \n\n# look at what the simulation summary contains\nnames(sim)\n\n[1] \"summary\"    \"flag\"       \"system\"     \"parameters\"\n\n\nThe first element is the sim summary. This contains a record of the history of speciation, extinction, and species richness through time (phylo_summary), a history of the number of total grid cells occupied during the simulation through time (occupancy) and the species richness of each grid cell at the final time step.\n\nstr(sim$summary)\n\nList of 3\n $ phylo_summary : num [1:52, 1:4] 4 4 4 4 4 4 4 4 4 4 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:52] \"initial\" \"50\" \"49\" \"48\" ...\n  .. ..$ : chr [1:4] \"total\" \"alive\" \"speciations\" \"extinctions\"\n $ occupancy     : Named num [1:52] 1 0.523 0.527 0.525 0.51 ...\n  ..- attr(*, \"names\")= chr [1:52] \"initial\" \"50\" \"49\" \"48\" ...\n $ richness-final: num [1:3600, 1:3] 0.5 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:3600] \"1\" \"2\" \"3\" \"4\" ...\n  .. ..$ : chr [1:3] \"x\" \"y\" \"0\"\n\n# phylo summary\nhead(sim$summary$phylo_summary)\n\n        total alive speciations extinctions\ninitial     4     4           4           0\n50          4     4           0           0\n49          4     4           0           0\n48          4     4           0           0\n47          4     4           0           0\n46          4     4           0           0\n\n# occupancy\nhead(sim$summary$occupancy)\n\n  initial        50        49        48        47        46 \n1.0000000 0.5225677 0.5270793 0.5249294 0.5099819 0.5013193 \n\n# occupancy\nhead(sim$summary$`richness-final`)\n\n    x    y 0\n1 0.5 59.5 0\n2 1.5 59.5 0\n3 2.5 59.5 0\n4 3.5 59.5 0\n5 4.5 59.5 0\n6 5.5 59.5 0\n\n\nThese data can be visualized with the plot_summary function\n\n# Visualize the outputs \nplot_summary(sim)\n\n\n\n\nWe can also use these data to map out patterns of species richness\n\n# make sure the landscape is loaded\nlc &lt;- readRDS(file.path(\"data\", \"landscapes\", \"islands\",\"landscapes.rds\"))\n\n# can remove cells with elevation below sea level at timestep 0 (present-day) to see the outlines of the islands\nna_mask &lt;- is.na(lc$elevation[,\"0\"])\nrich &lt;- sim$summary$`richness-final`\nrich[na_mask,3] &lt;- NA\n\n# turn richness summary into a raster \nrichness &lt;- rast(rich, type=\"xyz\")\n\n# plot, the sea is darblue, given by hexadecimal color code \nplot(richness, col=c(\"grey\", gen3sis::color_richness(12)), colNA=\"#000033\")\n\n\n\n\nThe next part of the simulation summary object is the flag which will tell us if the simulation ran successfully. It should give ‚ÄúOK‚Äù\n\nsim$flag\n\n[1] \"OK\"\n\n\nNext is the system summary. This is information about the R version, R packages, and operating system used in the simulation. This ensures complete repeatability. It also tells us the runtime of the simulation.\n\nnames(sim$system)\n\n[1] \"runtime-hours\"       \"gen3sis-version\"     \"R-version\"          \n[4] \"OS\"                  \"session-information\"\n\nsim$system[1:2]\n\n$`runtime-hours`\n[1] 0.01416649\n\n$`gen3sis-version`\n[1] '1.5.11'\n\n\nFinally the summary object contains the config information and model parameters used.\n\nnames(sim$parameters)\n\n[1] \"gen3sis\"     \"user\"        \"directories\"\n\nnames(sim$parameters$gen3sis)\n\n[1] \"general\"        \"initialization\" \"dispersal\"      \"speciation\"    \n[5] \"mutation\"       \"ecology\"       \n\n\n\n\nPhylogeny object (phy.nex)\nThe phylogeny object is pretty straight forward. It is a nexus file containing the relationships between the species.\n\n# read phy\nphy &lt;- read.nexus(file.path(output_dir, \"config_islands_simple_Day1Prac3_M3/phy.nex\"))\n# plot phy\nplot(phy, cex=0.4)\naxisPhylo()\n\n\n\n\nFrom this object we can look at lineages through time plots and estimate trends in diversification. The gamma statistic is one way to detect diversification slowdowns or speedups, with positive values indicating nodes are more closely pushed up towards the tips (speed up) and negative values indicating nodes are closer to the root (slowdown) (Pybus and Harvey 2000). There are lots of other kinds of measures of phylogenetic tree shape, such as metrics of tree imbalance (Colless‚Äôs Index, Beta-Splitting Paramater, etc.)\n\n# plot an ltt\nltt_M1 &lt;-ltt(phy)\n\n\n\n# look at the gamma statistic\nprint(paste0(\"Gamma = \", round(ltt_M1$gamma, 2)))\n\n[1] \"Gamma = 0.27\"\n\n# is there a significant deviation from constant rates?\nprint(paste0(\"P = \", round(ltt_M1$p, 2)))\n\n[1] \"P = 0.79\"\n\n\n\n\nSpecies objects (phy.nex)\nNow its time to get into the meat of the gen3sis outputs. Most of the information from the simulation is stored in the species objects. These are .rds files that contain a list which includes information on every species, extinct or extant, that existed during the simulation. These are saved per default at every time step, but can be fine tuned according to your needs. The naming convention is ‚Äúspecies_t_0.rds‚Äù for time step 0 (present-day), and ‚Äúspecies_t_50‚Äù for timestep 50, etc.\n\n# load object\nspecies_t_0 &lt;- readRDS(file.path(output_dir, \"config_islands_simple_Day1Prac3_M3\", \"species\", \"species_t_0.rds\"))\n\n# look at object class and length\nclass(species_t_0)\n\n[1] \"list\"\n\nlength(species_t_0)\n\n[1] 37\n\n# compare to number of tips in the phylogeny\nNtip(phy)\n\n[1] 37\n\n\nThere are 14 elements in the list, representing our 14 species and this number matches the number of species in our phylogeny. No species went extinct in this particular simulation, but if they did, they would match extinct tips in the phylogeny.\nLets look at a single species\n\nnames(species_t_0[[1]])\n\n[1] \"id\"         \"abundance\"  \"traits\"     \"divergence\"\n\n\nThe species has an ID which allows us to match it to the phylogeny.\n\nspecies_t_0[[1]]$id\n\n[1] \"1\"\n\n\nThe species‚Äô abundances are also linked to grid cells in the landscape, which can be matched with their corresponding names.\n\nspecies_t_0[[1]]$abundance\n\n249 250 251 252 289 290 291 306 307 308 316 349 352 353 354 364 365 366 377 378 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n406 407 408 414 415 423 439 440 465 466 467 476 482 500 524 525 560 561 584 597 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n619 620 645 656 657 662 678 679 705 706 716 717 723 737 738 766 776 783 784 785 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n796 797 827 835 845 846 847 848 853 854 888 889 890 893 894 909 910 951 953 \n  1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n\n\nIn this case the species has abundance values of 1 in all populations from the cells that it occupies. This is because we set abundances to be binary: 1=present, 0=absent. We can see the species occupies cells 247, 248, 249, etc.\nThe species also has values of it‚Äôs traits for each of its populations.\n\nhead(species_t_0[[1]]$traits)\n\n    dispersal temp_niche_centre temp_niche_width start_island\n249        10          20.81994              0.5            1\n250        10          20.91671              0.5            1\n251        10          20.84718              0.5            1\n252        10          20.83687              0.5            1\n289        10          20.83059              0.5            1\n290        10          20.83772              0.5            1\n\n\nWe can see the population that each row is linked by the rownames. Here you can see 247, 248, 249, etc. Each of these populations have a dispersal trait of 5 (because we didn‚Äôt vary this) slightly different temp_mean traits (because these evolved stochastically under a Brownian motion model) and a temp width of 1 (again, we didn;t vary this in model 1).\nSo, if we want to map out the distribution of species 1 at timestep 0, we just need to link those cell names (267/268/etc) to the landscape object and make a raster. Why don;t we try and see what islands species 1 is found on.\n\npar(mfrow=c(1,3))\n# first plot the islands out from the landscape object\npatch_xyz &lt;- rast(lc$patch[,c(\"x\", \"y\", \"0\")], type=\"xyz\")\nplot(patch_xyz, main=\"Island Patches\", col=palette()[c(2,3,4,6)], colNA=\"#000033\")\n\n# pull out values of the landscape where the species is found\nspecies1_xyz &lt;- lc$patch[which(rownames(lc$patch) %in% rownames(species_t_0[[1]]$traits)), c(\"x\", \"y\", \"0\")]\n\n# turn it into a raster\nspecies1_xyz &lt;- rast(species1_xyz, type=\"xyz\")\nspecies1_xyz &lt;- extend(species1_xyz, patch_xyz)\nplot(species1_xyz, main= \"Species 1 Distribution\", colNA=\"#000033\")\n\n# alternatively we can use the plot_species function on gen3sis..\n# for that we load the landscape object of the respective time-step\nlandscape_t_0 &lt;- readRDS(file.path(output_dir, \"config_islands_simple_Day1Prac3_M1\", \"landscapes\", \"landscape_t_0.rds\"))\ngen3sis::plot_species_presence(species_t_0[[1]], landscape_t_0)\n\n\n\n\n\n\nLinking the species object and phylogeny\nLets try and link the species trait data to the phylogeny to start learning something about what exactly took place during our simulation! Let‚Äôs get the mean trait value of the temperature niche and also the islands that each species belongs too.\n\n# lets create a data frame\ndaf &lt;- data.frame(\"id\"= paste0(\"species\",sapply(species_t_0, function(x)x$id)),\n                 \"mean_temp\"=NA,\n                 \"island1\"=0,\n                 \"island2\"=0,\n                 \"island3\"=0,\n                 \"island4\"=0, \n                 \"island_start\"=NA)\n\n# take a look\nhead(daf)\n\n        id mean_temp island1 island2 island3 island4 island_start\n1 species1        NA       0       0       0       0           NA\n2 species2        NA       0       0       0       0           NA\n3 species3        NA       0       0       0       0           NA\n4 species4        NA       0       0       0       0           NA\n5 species5        NA       0       0       0       0           NA\n6 species6        NA       0       0       0       0           NA\n\n# Use sapply on the species object to get their mean trait values\ndaf$mean_temp &lt;- sapply(species_t_0, function(x){\n  # x &lt;- species_t_0[[1]]\n  mean(x$traits[, \"temp_niche_centre\"], na.rm=T)\n  })\n\n# Get the island patch id values in a for loop\nfor(i in 1:length(species_t_0)){\n  #I'm here because it is a good idea to test code on a single species before running it on all species\n  # i &lt;- 1 \n  # as before we get the lanscape values of each species\n  speciesi_xyz &lt;- lc$patch[which(rownames(lc$patch) %in% rownames(species_t_0[[i]]$traits)), c(\"x\", \"y\", \"0\")]\n  \n  # then pull out the unique values (note that species might occur on more than one island)\n  islands &lt;- unique(speciesi_xyz[, 3])\n  \n  # then if species are on the island, give that column a value of 1\n  \n  daf$island1[i] &lt;- ifelse(1 %in% islands, 1, 0)\n  daf$island2[i] &lt;- ifelse(2 %in% islands, 1, 0)\n  daf$island3[i] &lt;- ifelse(3 %in% islands, 1, 0)\n  daf$island4[i] &lt;- ifelse(4 %in% islands, 1, 0)\n}\n\n# get the starting island from the traits object since we recorded this in the initialization step\ndaf$island_start &lt;- sapply(species_t_0, function(xasa) unique(xasa$traits[, \"start_island\"]))\n\nNow look again at the data frame\n\nhead(daf)\n\n        id mean_temp island1 island2 island3 island4 island_start\n1 species1  20.85480       1       1       0       0            1\n2 species2  20.97846       1       0       0       0            2\n3 species3  21.05220       0       0       1       0            3\n4 species4  21.98701       0       0       0       1            4\n5 species5  20.92045       1       1       0       0            2\n6 species6  20.82620       1       1       0       0            1\n\n\nPlot out the continuously evolving temperature niche trait\n\n# create a named vector for the log of the temperature niche trait\ntemp_niche &lt;- daf$mean_temp\nnames(temp_niche) &lt;- daf$id\n\n# plot it out with dots = trait\ndotTree(phy,temp_niche,ftype=\"i\", length=8, fsize=1.2, standardize=T)\n\n\n\n\nNot much variation in that trait, due to the combined effects of trait homogenization and a low rate of change. Lets plot the tip states of the islands on the phylogeny using the phytools package\n\npar(mfrow=c(1,2))\n\n# format each island\nformatIsland &lt;- function(island, phy=phy, daf=daf){\n  islandf &lt;- as.factor(daf[, island])\n  names(islandf) &lt;- daf$id\n  islandmat&lt;-to.matrix(islandf,levels(islandf))\n  islandmat&lt;-islandmat[phy$tip.label,]\n  return(list(islandf, islandmat))\n}\n\n\nplotTree(phy,ftype=\"i\",offset=1,fsize=0.9, xlim=c(0, 75))\n\ntiplabels(pie=formatIsland(island=\"island1\", phy=phy, daf=daf)[[2]],piecol=palette()[c(8,2)],cex=0.6, adj=12+1)\ntiplabels(pie=formatIsland(island=\"island2\", phy=phy, daf=daf)[[2]],piecol=palette()[c(8,3)],cex=0.6, adj=12+3)\ntiplabels(pie=formatIsland(island=\"island3\", phy=phy, daf=daf)[[2]],piecol=palette()[c(8,4)],cex=0.6, adj=12+5)\ntiplabels(pie=formatIsland(island=\"island4\", phy=phy, daf=daf)[[2]],piecol=palette()[c(8,6)],cex=0.6, adj=12+7)\n\nplot(patch_xyz, main=\"Island Patches\", col=palette()[c(2,3,4,6)])\n\n\n\n\nInteresting. What do you notice about the distribution of species on islands? Could you predict which island each lineage began on?\nWe actually know which islands each lineage started on because we recorded this as a trait (we could also look at the past species objects to figure this out but we have used a shortcut though the traits).\n\npar(mfrow=c(1,2))\nplotTree(phy,ftype=\"i\",offset=1,fsize=0.4, xlim=c(0, 75))\nmy_cex=0.9\n# add the starting island as the first colum\ntiplabels(pie=formatIsland(island=\"island_start\", phy=phy, daf=daf)[[2]],piecol=palette()[c(2,3,4,6)],cex=my_cex*3, adj=12)\n\ntiplabels(pie=formatIsland(island=\"island1\", phy=phy, daf=daf)[[2]],piecol=palette()[c(8,2)],cex=my_cex, adj=12+1)\ntiplabels(pie=formatIsland(island=\"island2\", phy=phy, daf=daf)[[2]],piecol=palette()[c(8,3)],cex=my_cex, adj=12+3)\ntiplabels(pie=formatIsland(island=\"island3\", phy=phy, daf=daf)[[2]],piecol=palette()[c(8,4)],cex=my_cex, adj=12+5)\ntiplabels(pie=formatIsland(island=\"island4\", phy=phy, daf=daf)[[2]],piecol=palette()[c(8,6)],cex=my_cex, adj=12+7)\n\n# add island plot\nplot(patch_xyz, main=\"Island Patches\", col=palette()[c(2,3,4,6)])\n\n\n\n\nSo whats really apparent here is that the clade that originated on the green island has speciated allopatrically into the red island multiple times in the recent past. The same is true for the red clade, however the deeper divergence between species9 and species3 have had enough time to recolonize both islands.\n\n\n4.0.0.1 Linking the species object, landscape, and phylogeny\nCommon spatial biodiversity analyses link information measured at the species level to maps of their distribution in space using presence-absence matrices or PAMs. PAMs typically are data frame with each row representing a site, could be an island or could be a grid cell, and each column representing a species. Values of 1 are given if the species is present in the site, if not a value of 0 is given.\n\n# grid cell level PAM\n\n# create an empty data frame with the dimensions of species x sites\nPAM &lt;- data.frame(matrix(0, nrow=nrow(lc$elevation), ncol=length(species_t_0)))\n\n# given names to rows and columns\nrownames(PAM) &lt;- rownames(lc$elevation)\ncolnames(PAM) &lt;- paste0(\"species\", sapply(species_t_0, function(x)x$id))\n\n# loop over species and add value of 1 to all sites the species is present\nfor(i in 1:length(species_t_0)){\n  \n  PAM[which(rownames(PAM) %in% names(species_t_0[[i]]$abundance)), i] &lt;- 1\n}\n\n# how does it look?\nprint(PAM[1:10, 1:10])\n\n   species1 species2 species3 species4 species5 species6 species7 species8\n1         0        0        0        0        0        0        0        0\n2         0        0        0        0        0        0        0        0\n3         0        0        0        0        0        0        0        0\n4         0        0        0        0        0        0        0        0\n5         0        0        0        0        0        0        0        0\n6         0        0        0        0        0        0        0        0\n7         0        0        0        0        0        0        0        0\n8         0        0        0        0        0        0        0        0\n9         0        0        0        0        0        0        0        0\n10        0        0        0        0        0        0        0        0\n   species9 species10\n1         0         0\n2         0         0\n3         0         0\n4         0         0\n5         0         0\n6         0         0\n7         0         0\n8         0         0\n9         0         0\n10        0         0\n\n\n\n# we can estimate Phylogenetic diversity\npd_islands &lt;- pd(PAM, phy)\n\n# we can also measure mean phylogenetic distance and mean nearest neighbour distance\nmpd_islands &lt;- mpd(PAM, cophenetic(phy))\nmntd_islands &lt;- mntd(PAM,cophenetic(phy))\n\n# link these back with the landscape by joining to the landscape lat/long\ncommunity_phylo &lt;- cbind(lc$elevation[, c(\"x\", \"y\")], pd_islands, mpd_islands, mntd_islands)\n\npar(mfrow=c(2,2))\nsr_ras &lt;- rast(community_phylo[, c(\"x\", \"y\", \"SR\")], type=\"xyz\")\npd_ras &lt;- rast(community_phylo[, c(\"x\", \"y\", \"PD\")], type=\"xyz\")\nmpd_ras &lt;- rast(community_phylo[, c(\"x\", \"y\", \"mpd_islands\")], type=\"xyz\")\nmntd_ras &lt;- rast(community_phylo[, c(\"x\", \"y\", \"mntd_islands\")], type=\"xyz\")\n\nplot(sr_ras, main=\"Species Richness\", na.color =\"red\")\nplot(pd_ras, main=\"Phylogenetic Diversity\")\nplot(mpd_ras, main=\"Mean Phylogenetic Pairwise Distance\")\nplot(mntd_ras, main= \"Mean Nearest Neighbour Phylogenetic Distance\")"
  },
  {
    "objectID": "Day2_Prac4_outputs.html#sensitivity-analysis",
    "href": "Day2_Prac4_outputs.html#sensitivity-analysis",
    "title": "4¬† üñ•Ô∏è Silicodiversity",
    "section": "Sensitivity analysis",
    "text": "Sensitivity analysis\nIn this part we are going to load in a data set from Skeels et al.¬†(2022) SystBiol in which we simulated data with Gen3sis under four alternative models to test the evolutionary speed hypothesis (ESH). The ESH hypothesizes that faster rates of evolution occurs in lineages from warm regions like the tropics because they are have higher mutagenesis from faster life histories associated with warm temperatures and smaller body sizes. The four models used there were\n\nM0 - the null. population divergence is independent of temperature and body size\nM1 - Temperature Trailblazer. environmental temperature drives rate of population divergence\nM2 - Size Shaper. body size drives the rate of population divergence\nM3 - Synergistic Drivers. environmental temperature and body size drives the rate of population divergence\n\n\n\n\nSkeels et al.¬†2022 Syst. Biol. Figure 1\n\n\nNot only did we change the overall model of evolution, we also varied key parameters for rates of niche evolution (simga_squared_t), rates of body size evolution (sigma_squared_bs), dispersal, and the temperature niche breadth (omega), the exponent of the divergence factor with temp/body size (lambda), and the divergence threshold. Load in the data and take a look, the first 6 columns are the model parameters we varied.\n\nsim_data &lt;- read.csv(\"data/simulated_summary_statistics.csv\")\n\n# look at the first few columns\nhead(sim_data)\n\n  divergence_threshold lambda omega sigma_squared_bs sigma_squared_t dispersal\n1                    6  3.497 0.022            0.010           0.008     2.748\n2                    8  2.743 0.029            0.006           0.012     2.119\n3                    4  4.251 0.016            0.015           0.004     3.376\n4                    5  3.120 0.026            0.003           0.013     3.691\n5                    9  4.629 0.013            0.013           0.006     2.433\n6                    7  2.365 0.019            0.008           0.003     3.062\n   m n_extant_diversity richness_lat_cor richness_temp0mya_cor temp_skewness\n1 m0               3763       -0.5123028             0.4603989    -0.3377488\n2 m0               2514       -0.4425833             0.3879755    -0.4301348\n3 m0               2881       -0.6090030             0.5980889    -0.5485366\n4 m0               3259       -0.2692291             0.2709599    -0.4056149\n5 m0               1720       -0.6320276             0.5569583    -0.2034315\n6 m0               2040       -0.6901237             0.7143851    -0.5818263\n  temp_kurtosis rs_skewness rs_kurtosis bodysize_temp_cor\n1      2.404199    7.054563    70.57922      0.0001267958\n2      2.781235    7.065556    73.60686     -0.0573601538\n3      2.686734    6.568041    66.80411      0.0627634742\n4      2.578726    6.372164    56.40946     -0.0099951252\n5      2.039092    5.943670    62.21730     -0.0491801922\n6      2.692505    5.557220    43.19415     -0.1425113733\n  bodysize_rangesize_cor rangesize_temp_cor bodysize_MRDa_cor bodysize_MRDn_cor\n1           -0.021888162          0.3166909       -0.22987475       -0.22987475\n2           -0.004099039          0.3750050        0.11431674        0.11431674\n3           -0.007583409          0.1745926       -0.17385167       -0.17385167\n4            0.019477523          0.3315223        0.15882106        0.15882106\n5           -0.020735305          0.3106268       -0.01367189       -0.01367189\n6           -0.068035906          0.2386339       -0.25345879       -0.25345879\n  bodysize_MRDs_cor bodysize_ED_cor bodysize_ES_cor bodysize_DR_cor\n1       -0.22987475    -0.004220075    -0.001379360     0.004220206\n2        0.11431674    -0.048918445    -0.047336234     0.048918445\n3       -0.17385167     0.156214848     0.124189954    -0.156214848\n4        0.15882106     0.025569939     0.020867045    -0.025569939\n5       -0.01367189    -0.091018579    -0.071841554     0.091018579\n6       -0.25345879    -0.011839185    -0.009998883     0.011839185\n  temp_MRDa_cor temp_MRDn_cor temp_MRDs_cor temp_ED_cor temp_ES_cor temp_DR_cor\n1   -0.26576712   -0.26576712   -0.26576712  0.26183743   0.2202009 -0.26183732\n2   -0.17175772   -0.17175772   -0.17175772  0.24312164   0.2193826 -0.24312164\n3   -0.26126033   -0.26126033   -0.26126033  0.20306519   0.2015201 -0.20306519\n4   -0.18047283   -0.18047283   -0.18047283  0.09627562   0.0921575 -0.09627562\n5   -0.29855804   -0.29855804   -0.29855804  0.51772365   0.4230468 -0.51772365\n6    0.05847105    0.05847105    0.05847105  0.11024859   0.1080941 -0.11024859\n  rangesize_MRDa_cor rangesize_MRDn_cor rangesize_MRDs_cor rangesize_ED_cor\n1        -0.06934918        -0.06934918        -0.06934918       0.08511133\n2        -0.10091990        -0.10091990        -0.10091990       0.12507118\n3         0.04022504         0.04022504         0.04022504      -0.09452590\n4        -0.04660310        -0.04660310        -0.04660310       0.07933631\n5        -0.13259037        -0.13259037        -0.13259037       0.18191779\n6         0.06267093         0.06267093         0.06267093      -0.01025940\n  rangesize_ES_cor rangesize_DR_cor  collessI    sackinI     gamma  lat_pd_cor\n1      0.077434173      -0.08511127 1.2941150  1.2446979 -2.842964  0.31465895\n2      0.122658910      -0.12507118 0.2469526  0.3055442 -3.432895  0.25315279\n3     -0.069705157       0.09452590 1.7248814  1.6445494  3.552396  0.18284230\n4      0.087443271      -0.07933631 0.1092457 -0.1254847 -2.856134  0.11539323\n5      0.147346956      -0.18191779 1.9250034  1.8373325  1.221135 -0.06489522\n6      0.006120436       0.01025940 1.4952264  1.3605311 -5.120426  0.53662583\n  lat_mpd_cor lat_mntd_cor temp_pd_cor temp_mpd_cor temp_mntd_cor\n1  0.03036122   0.33145967 -0.24781657   0.01816540  -0.268472337\n2  0.10829373   0.24772423 -0.19630776  -0.09235074  -0.184665665\n3  0.18551711   0.24143456 -0.18427695  -0.19302604  -0.243213118\n4 -0.03477720   0.15145822 -0.09837927   0.03810852  -0.129764794\n5 -0.20454388   0.09798374  0.14050779   0.24629073  -0.006957113\n6  0.46224942   0.53924111 -0.54984407  -0.47923803  -0.551691573\n  richness_pd_cor richness_mpd_cor richness_mntd_cor temp_bsm_cor temp_bssd_cor\n1      -0.7653721      -0.41190740        -0.7499123   0.13029352    0.10296607\n2      -0.5019377      -0.13404370        -0.4901978   0.02405246    0.32276835\n3      -0.4206957      -0.37006059        -0.5361401   0.29116267    0.28959998\n4      -0.6620540      -0.41176821        -0.6769946  -0.05320780    0.04856645\n5      -0.1328847       0.06086838        -0.2905060  -0.08286640    0.08193951\n6      -0.8328187      -0.71895993        -0.8346579   0.31747185    0.34586235\n  richness_bsm_cor richness_bssd_cor   pd_bsm_cor mpd_bsm_cor mntd_bsm_cor\n1       0.11558582         0.2699839  0.003325102   0.2260060  -0.05039301\n2      -0.04537885         0.3499518 -0.263036186  -0.2484294  -0.25064129\n3       0.23668036         0.3628398  0.515713659   0.4795434   0.49672112\n4       0.04042515         0.1778522 -0.052266148  -0.1187109  -0.03605613\n5       0.31046985         0.3722813  0.061612978   0.1029425   0.06221910\n6       0.45747017         0.3837205 -0.038428520   0.3474728  -0.12562991\n\n# look at the models\nunique(sim_data$m)\n\n[1] \"m0\" \"m1\" \"m2\" \"m3\"\n\n\nThis data set has 27 metrics used in our paper to measure patterns in the distribution of species, such as range size metrics, or correlations between temperature and diversity, as well as phylogenetic tree shape metrics, such as gamma, and measures of functional diversity, like body size variance. We predicted that these different models of evolution (M0-M4) should leave discernible signatures in these metrics. We can plot a few associations between biodiversity metrics and these model parameters to test this hypothesis.\n\nrequire(ggplot2)\n\n# how is diversity related to the dispersal ability of a clade?\nggplot(sim_data, aes(x=m, y=log(n_extant_diversity), fill=m))+\n  geom_point(alpha=0.7, position = \"jitter\")+\n  geom_boxplot(alpha=0.7)+\n  stat_smooth()+\n  theme_classic()\n\n\n\n# how about the temperature~diversity gradient?\nggplot(sim_data, aes(x=m, y=richness_temp0mya_cor, fill=m))+\n  geom_point(alpha=0.7, position = \"jitter\")+\n  geom_boxplot(alpha=0.7)+\n  stat_smooth()+\n  theme_classic()\n\n\n\n# how about the relationship between  body size and diversification rate?\nggplot(sim_data, aes(x=m, y=bodysize_DR_cor, fill=m))+\n  geom_point(alpha=0.7, position = \"jitter\")+\n  geom_boxplot(alpha=0.7)+\n  stat_smooth()+\n  theme_classic()\n\n\n\n# how about the relationship between temperature and diversification rate?\nggplot(sim_data, aes(x=m, y=temp_DR_cor, fill=m))+\n  geom_point(alpha=0.7, position = \"jitter\")+\n  geom_boxplot(alpha=0.7)+\n  stat_smooth()+\n  theme_classic()\n\n\n\n\nDo these patterns fit our predictions? We can also look at how some of these metrics varied with the continuous model parameters such as dispersal ability.\n\n# how is diversity related to the dispersal ability of a clade?\nggplot(sim_data, aes(x=dispersal, y=log(n_extant_diversity)))+\n  geom_point(alpha=0.7)+\n  stat_smooth()+\n  theme_classic()\n\n\n\n# how about the latitude diversity gradient?\nggplot(sim_data, aes(x=dispersal, y=temp_DR_cor))+\n  geom_point(alpha=0.7)+\n  stat_smooth()+\n  theme_classic()\n\n\n\n\nTo perform a simple kind of sensitivity test we might ask how each of the model parameters predicts linear changes in the distribution of a biodiversity patterns using a multiple regression model. One example where we have a good idea of what the relationship should be is the how variance in the distribution of temperature niches across species (e.g., skewness of the distribution) relates to model paramaters. We expect that this should scale with the rate of rate of temperature niche evolution - faster rates of change = more variation in the trait = more kutosis.\n\n# first scale parameters to be in the same units\nsim_data_scaled &lt;- sim_data\nsim_data_scaled[,1:6] &lt;- scale(sim_data_scaled[,1:6] )\n\n# fit the multiple regression\nlm1  &lt;- lm(temp_kurtosis ~ divergence_threshold+lambda+omega+sigma_squared_bs+sigma_squared_t+dispersal, data=sim_data_scaled)\n\n# look at model coefficients\nsummary(lm1)\n\n\nCall:\nlm(formula = temp_kurtosis ~ divergence_threshold + lambda + \n    omega + sigma_squared_bs + sigma_squared_t + dispersal, data = sim_data_scaled)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-2.7214 -0.7281 -0.3103  0.2481 22.9740 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)           3.26301    0.04670  69.872  &lt; 2e-16 ***\ndivergence_threshold  0.48515    0.04978   9.745  &lt; 2e-16 ***\nlambda                0.22304    0.04717   4.729 2.49e-06 ***\nomega                 0.07447    0.04769   1.562    0.119    \nsigma_squared_bs      0.02415    0.04677   0.516    0.606    \nsigma_squared_t       0.29197    0.04690   6.225 6.37e-10 ***\ndispersal             0.26180    0.04915   5.326 1.17e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.737 on 1377 degrees of freedom\nMultiple R-squared:  0.1076,    Adjusted R-squared:  0.1037 \nF-statistic: 27.68 on 6 and 1377 DF,  p-value: &lt; 2.2e-16\n\n\nWhat do you see? Are our expectations met? Any surprises? Let‚Äôs try a few other biodiversity patterns where the predictions are less clear.\n\n# fit the multiple regressions\n\n# Gamma statsitic for phylogenetic tree shape\nlm2  &lt;- lm(gamma ~ divergence_threshold+lambda+omega+sigma_squared_bs+sigma_squared_t+dispersal, data=sim_data_scaled)\n\n# skewness of the range size distribution of species\nlm3  &lt;- lm(rs_skewness ~ divergence_threshold+lambda+omega+sigma_squared_bs+sigma_squared_t+dispersal, data=sim_data_scaled)\n\n# correlation between species range sizes and temperature\nlm4  &lt;- lm(rangesize_temp_cor ~ divergence_threshold+lambda+omega+sigma_squared_bs+sigma_squared_t+dispersal, data=sim_data_scaled)\n\n# look at model coefficients\nsummary(lm2)\n\n\nCall:\nlm(formula = gamma ~ divergence_threshold + lambda + omega + \n    sigma_squared_bs + sigma_squared_t + dispersal, data = sim_data_scaled)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-14.6901  -3.3262  -0.3125   3.0625  19.1039 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)           1.58975    0.13209  12.035  &lt; 2e-16 ***\ndivergence_threshold -1.67245    0.14081 -11.877  &lt; 2e-16 ***\nlambda               -0.36850    0.13341  -2.762  0.00582 ** \nomega                 1.13745    0.13489   8.432  &lt; 2e-16 ***\nsigma_squared_bs      0.04682    0.13230   0.354  0.72347    \nsigma_squared_t      -0.17454    0.13266  -1.316  0.18848    \ndispersal             0.99940    0.13903   7.188 1.07e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.914 on 1377 degrees of freedom\nMultiple R-squared:  0.2175,    Adjusted R-squared:  0.2141 \nF-statistic: 63.78 on 6 and 1377 DF,  p-value: &lt; 2.2e-16\n\nsummary(lm3)\n\n\nCall:\nlm(formula = rs_skewness ~ divergence_threshold + lambda + omega + \n    sigma_squared_bs + sigma_squared_t + dispersal, data = sim_data_scaled)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-5.5219 -1.7186 -0.2771  1.3923 21.2181 \n\nCoefficients:\n                     Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)           6.14631    0.06701  91.717  &lt; 2e-16 ***\ndivergence_threshold -2.11448    0.07144 -29.598  &lt; 2e-16 ***\nlambda               -0.60219    0.06768  -8.897  &lt; 2e-16 ***\nomega                -0.31157    0.06844  -4.553 5.76e-06 ***\nsigma_squared_bs      0.22387    0.06712   3.335 0.000875 ***\nsigma_squared_t      -0.57043    0.06730  -8.476  &lt; 2e-16 ***\ndispersal            -1.33498    0.07053 -18.927  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.493 on 1377 degrees of freedom\nMultiple R-squared:  0.4552,    Adjusted R-squared:  0.4528 \nF-statistic: 191.8 on 6 and 1377 DF,  p-value: &lt; 2.2e-16\n\nsummary(lm4)\n\n\nCall:\nlm(formula = rangesize_temp_cor ~ divergence_threshold + lambda + \n    omega + sigma_squared_bs + sigma_squared_t + dispersal, data = sim_data_scaled)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.72559 -0.08895  0.01488  0.09329  0.68488 \n\nCoefficients:\n                      Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)           0.197748   0.004238  46.658  &lt; 2e-16 ***\ndivergence_threshold -0.029361   0.004518  -6.498 1.13e-10 ***\nlambda               -0.022882   0.004281  -5.345 1.05e-07 ***\nomega                -0.042760   0.004328  -9.879  &lt; 2e-16 ***\nsigma_squared_bs     -0.001199   0.004245  -0.283    0.778    \nsigma_squared_t       0.041124   0.004256   9.662  &lt; 2e-16 ***\ndispersal            -0.019362   0.004461  -4.340 1.53e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.1577 on 1377 degrees of freedom\nMultiple R-squared:  0.1388,    Adjusted R-squared:  0.135 \nF-statistic: 36.99 on 6 and 1377 DF,  p-value: &lt; 2.2e-16\n\n\nIn all these cases there are interesting associations between model parameters and the biodiversity metrics. However, look at the R-squared values and what do you find? They are highly variable and in some cases quite low. This means that lots of variance in these biodiversity metrics are not explained by a linear combination of our model parameters. This is important when interpreting the effect. There are other ways of inferring more complex relationships between model parameters and biodiversity metrics, such as by including quadratic effects, exploring interaction terms, fitting non-linear models such as generalised additive models (GAMs), or even using machine learning methods such as neural networks which allow for highly-dimension non-linear effects. We won‚Äôt cover these today but they are all useful options to explore during sensitivity analysis.\n\n4.0.1 Model Selection\nOnce we have established that some biodiversity metrics showed predictable relationships with model parameters or the generative model (e.g., M0-M4) we can use these metrics to perform model selection on empirical data. Here we are using the match between observed biodiversity patterns and simulated biodiversity patterns, to ask which model might be most likely to have generated the real patterns.\n\n\n\nSkeels et al.¬†2022 Syst. Biol. Figure 2\n\n\nTo do this we are going to perform a linear discriminant analysis which is a classification tool that can fit fit fairly quickly compared to some of the other models. We want to validate how well the model performs so we will perform a 10-fold cross validation repeated 10 times. Here we train the model on a subset of the data, repeating the process and optimising the predictive capacity. Then we predict how good a job our classifier is on a witheld portion of the data (test data). If the model performs well we should be able to accurately predict what models generated what biodiversity metrics.\n\nrequire(caret)\n# get just the biodiversity metrics\nsim_data_ms &lt;- sim_data[,7:ncol(sim_data)]\n\n# remove MRDs variables from sim data\nsim_data_ms &lt;- sim_data_ms[, -which(grepl(\"MRDs\",colnames(sim_data_ms)))]\n\n# partition into a training and testing dataset for cross validation\ntrain_index &lt;- createDataPartition(sim_data_ms$m, p = .66, list = FALSE,  times = 1)\ntrain_data &lt;- sim_data_ms[ train_index ,]\ntest_data  &lt;- sim_data_ms[-train_index ,]\n\n# preprocess values - we will scale and center values\npreprocessed_values &lt;- preProcess(train_data, method = c(\"center\", \"scale\"))\ntrain_transformed   &lt;- predict(preprocessed_values, train_data)\ntest_transformed    &lt;- predict(preprocessed_values, test_data )\n\n# configure the cross-validation paramaters\ntrain_control &lt;- trainControl( method = \"repeatedcv\", number = 10, repeats = 10, classProbs = TRUE, savePredictions = TRUE)\n\n# FIT MODELS\nf1 &lt;- formula(paste(\"m ~ \", paste(names(sim_data_ms)[2:c(length(names(sim_data_ms)))], collapse=\" + \")))\n\n## LINEAR DISCRIMINANT ANALYSIS\n# note we'll run an LDA because they're quick - many other kinds of models to choose from \nlda_train        &lt;- train(f1, data=train_transformed, method = \"lda\", trControl = train_control, verbose = T)\n\n#predict on test data\nlda_test        &lt;- predict(lda_train, test_transformed)\n\n# classification accuracy\nlda_cm        &lt;- confusionMatrix(data = lda_test, reference = as.factor(test_transformed$m), mode = \"prec_recall\")\n\n# how well did the model perform\nlda_cm \n\nConfusion Matrix and Statistics\n\n          Reference\nPrediction  m0  m1  m2  m3\n        m0 102  18   1   6\n        m1   6  91   3  10\n        m2   0   1  81  24\n        m3   9   6  32  77\n\nOverall Statistics\n                                          \n               Accuracy : 0.7516          \n                 95% CI : (0.7098, 0.7902)\n    No Information Rate : 0.2505          \n    P-Value [Acc &gt; NIR] : &lt; 2e-16         \n                                          \n                  Kappa : 0.6688          \n                                          \n Mcnemar's Test P-Value : 0.09666         \n\nStatistics by Class:\n\n                     Class: m0 Class: m1 Class: m2 Class: m3\nPrecision               0.8031    0.8273    0.7642    0.6210\nRecall                  0.8718    0.7845    0.6923    0.6581\nF1                      0.8361    0.8053    0.7265    0.6390\nPrevalence              0.2505    0.2484    0.2505    0.2505\nDetection Rate          0.2184    0.1949    0.1734    0.1649\nDetection Prevalence    0.2719    0.2355    0.2270    0.2655\nBalanced Accuracy       0.9002    0.8652    0.8104    0.7619\n\n\nWhats the overall accuracy? Are some models predicted better than others?\nNow we‚Äôll use this model to predict the possible model of diversification in orders of terrestrial vertebrates.\n\n# first subset and clean the colnames of the empirical data\nempirical_data &lt;- read.csv(\"data/order_empirical_summary_statistics.csv\")\n\n# just want to look at diverse clades\nempirical_data &lt;- na.omit(empirical_data[which(empirical_data$n_species &gt;= 20),])\n\n# make labels lower case\nempirical_data$taxon &lt;- tolower(empirical_data$taxon)\n\n# clean up a few names because I'm a grub\ncolnames(empirical_data)[which(colnames(empirical_data) == \"taxon\")] &lt;- \"m\"\ncolnames(empirical_data)[which(colnames(empirical_data)==\"rs_kutosis\")] &lt;- \"rs_kurtosis\"\ncolnames(empirical_data)[which(colnames(empirical_data)==\"n_species\")] &lt;- \"n_extant_diversity\"\ncolnames(empirical_data) &lt;- gsub(\"_p_cor\", \"_cor\",colnames(empirical_data)) # change _p_cor for posterior samplescould also change _m_cor to use MCC samples\ncolnames(empirical_data) &lt;- gsub(\"DivRate\", \"DR\",colnames(empirical_data))\ncolnames(empirical_data)[which(colnames(empirical_data) == \"taxon\")] &lt;- \"m\"\ncolnames(empirical_data)[which(colnames(empirical_data) == \"collessI_posterior\")] &lt;- \"collessI\"\ncolnames(empirical_data)[which(colnames(empirical_data) == \"sackinI_mcc\")] &lt;- \"sackinI\"\ncolnames(empirical_data)[which(colnames(empirical_data) == \"gamma_mcc\")] &lt;- \"gamma\"\n\n\n# ok these should be able to be matched now\nempirical_data &lt;- empirical_data[, which(colnames(empirical_data) %in% colnames(sim_data_ms))]\nempirical_subset &lt;- empirical_data[, match(colnames(sim_data_ms), colnames(empirical_data))]\n\n# check names match\ncolnames(sim_data_ms)[which(!colnames(sim_data_ms) %in% colnames(empirical_subset))]\n\ncharacter(0)\n\ncolnames(empirical_subset)[which(!colnames(empirical_subset) %in% colnames(sim_data_ms))]\n\ncharacter(0)\n\ncolnames(empirical_subset) == colnames(sim_data_ms)\n\n [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n[31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE\n\n# Process empirical data in the same way as for the simulated data\nsimulated_transformed &lt;- predict(preprocessed_values, sim_data_ms )\nempirical_transformed &lt;- predict(preprocessed_values, empirical_subset )\n\nmodel_set &lt;- list(lda_train)\n\n# predict on empirical\nclass_predictions   &lt;- predict(model_set, newdata = empirical_transformed, type = \"raw\", na.action = na.omit)\nclass_probabilities &lt;- predict(model_set, newdata = empirical_transformed, type = \"prob\", na.action = na.omit)\n\n# sum the classes\ncolSums(do.call(rbind, class_predictions)) # TODO define class prediction table\n\n [1] 3 4 1 2 1 1 4 1 3 3 1 4 2 3 1 4 4 4 3 2 1 1 3 2 1 1 4 4 4 3 4 1 4 4 3 4 1 4\n[39] 1 4 1 3 4 3 4 2 4 1\n\n# now we can see which model is the most supported for each order\ncbind(empirical_transformed$m, as.character(class_predictions[[1]]))\n\n      [,1]                [,2]\n [1,] \"serpentes\"         \"m2\"\n [2,] \"anguimorpha\"       \"m3\"\n [3,] \"dibamia\"           \"m0\"\n [4,] \"gekkota\"           \"m1\"\n [5,] \"iguania\"           \"m0\"\n [6,] \"lacertoidea\"       \"m0\"\n [7,] \"scincoidea\"        \"m3\"\n [8,] \"afrosoricida\"      \"m0\"\n [9,] \"carnivora\"         \"m2\"\n[10,] \"cetartiodactyla\"   \"m2\"\n[11,] \"chiroptera\"        \"m0\"\n[12,] \"cingulata\"         \"m3\"\n[13,] \"dasyuromorphia\"    \"m1\"\n[14,] \"didelphimorphia\"   \"m2\"\n[15,] \"diprotodontia\"     \"m0\"\n[16,] \"eulipotyphla\"      \"m3\"\n[17,] \"lagomorpha\"        \"m3\"\n[18,] \"primates\"          \"m3\"\n[19,] \"rodentia\"          \"m2\"\n[20,] \"scandentia\"        \"m1\"\n[21,] \"accipitriformes\"   \"m0\"\n[22,] \"anseriformes\"      \"m0\"\n[23,] \"apodiformes\"       \"m2\"\n[24,] \"bucerotiformes\"    \"m1\"\n[25,] \"caprimulgiformes\"  \"m0\"\n[26,] \"charadriiformes\"   \"m0\"\n[27,] \"columbiformes\"     \"m3\"\n[28,] \"coraciiformes\"     \"m3\"\n[29,] \"cuculiformes\"      \"m3\"\n[30,] \"falconiformes\"     \"m2\"\n[31,] \"galliformes\"       \"m3\"\n[32,] \"gruiformes\"        \"m0\"\n[33,] \"musophagiformes\"   \"m3\"\n[34,] \"otidiformes\"       \"m3\"\n[35,] \"passeriformes\"     \"m2\"\n[36,] \"pelecaniformes\"    \"m3\"\n[37,] \"piciformes\"        \"m0\"\n[38,] \"procellariiformes\" \"m3\"\n[39,] \"psittaciformes\"    \"m0\"\n[40,] \"strigiformes\"      \"m3\"\n[41,] \"suliformes\"        \"m0\"\n[42,] \"tinamiformes\"      \"m2\"\n[43,] \"trogoniformes\"     \"m3\"\n[44,] \"anura\"             \"m2\"\n[45,] \"caudata\"           \"m3\"\n[46,] \"gymnophiona\"       \"m1\"\n[47,] \"crocodylia\"        \"m3\"\n[48,] \"testudines\"        \"m0\"\n\ntable(class_predictions[[1]])\n\n\nm0 m1 m2 m3 \n15  5 10 18 \n\n# can also look at the variation in this\ncbind(empirical_transformed$m, round(class_probabilities[[1]], 3))\n\n   empirical_transformed$m    m0    m1    m2    m3\n1                serpentes 0.081 0.000 0.919 0.000\n2              anguimorpha 0.000 0.000 0.000 1.000\n3                  dibamia 1.000 0.000 0.000 0.000\n4                  gekkota 0.000 0.655 0.000 0.345\n5                  iguania 1.000 0.000 0.000 0.000\n6              lacertoidea 1.000 0.000 0.000 0.000\n7               scincoidea 0.000 0.000 0.000 1.000\n8             afrosoricida 1.000 0.000 0.000 0.000\n9                carnivora 0.000 0.000 1.000 0.000\n10         cetartiodactyla 0.176 0.000 0.824 0.000\n11              chiroptera 0.880 0.000 0.120 0.000\n12               cingulata 0.000 0.000 0.000 1.000\n13          dasyuromorphia 0.000 1.000 0.000 0.000\n15         didelphimorphia 0.000 0.000 1.000 0.000\n16           diprotodontia 1.000 0.000 0.000 0.000\n17            eulipotyphla 0.000 0.000 0.000 1.000\n19              lagomorpha 0.000 0.000 0.000 1.000\n28                primates 0.000 0.000 0.000 1.000\n30                rodentia 0.000 0.000 1.000 0.000\n31              scandentia 0.002 0.998 0.000 0.000\n33         accipitriformes 1.000 0.000 0.000 0.000\n34            anseriformes 1.000 0.000 0.000 0.000\n35             apodiformes 0.000 0.000 1.000 0.000\n37          bucerotiformes 0.000 1.000 0.000 0.000\n38        caprimulgiformes 1.000 0.000 0.000 0.000\n41         charadriiformes 0.972 0.028 0.000 0.000\n44           columbiformes 0.000 0.001 0.000 0.999\n45           coraciiformes 0.000 0.000 0.000 1.000\n46            cuculiformes 0.000 0.000 0.000 1.000\n48           falconiformes 0.016 0.000 0.984 0.000\n49             galliformes 0.000 0.000 0.000 1.000\n51              gruiformes 1.000 0.000 0.000 0.000\n53         musophagiformes 0.000 0.000 0.000 1.000\n54             otidiformes 0.000 0.000 0.000 1.000\n55           passeriformes 0.000 0.000 1.000 0.000\n56          pelecaniformes 0.000 0.000 0.032 0.968\n59              piciformes 0.999 0.000 0.001 0.000\n61       procellariiformes 0.000 0.000 0.000 1.000\n62          psittaciformes 0.672 0.328 0.000 0.000\n66            strigiformes 0.000 0.000 0.000 1.000\n67              suliformes 1.000 0.000 0.000 0.000\n68            tinamiformes 0.000 0.000 0.775 0.225\n69           trogoniformes 0.000 0.000 0.000 1.000\n70                   anura 0.000 0.000 0.941 0.059\n71                 caudata 0.000 0.000 0.000 1.000\n72             gymnophiona 0.031 0.968 0.000 0.001\n73              crocodylia 0.000 0.000 0.000 1.000\n74              testudines 1.000 0.000 0.000 0.000\n\n\nWhat patterns do you see? Which models are the most supported?"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html",
    "href": "Day2_Prac5_landscapes.html",
    "title": "5¬† üåã Creating Worlds",
    "section": "",
    "text": "Introduction\nWelcome, brave explorer of virtual worlds! Today, you‚Äôll learn how to create entire landscapes (no pressure!) using R. We‚Äôll shrink the universe to an experimental size, start with one island and gradually add more complexity; from rugosity to temperature, and even sea level changes.\nIn this tutorial, we will:"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#step-1-setup-gather-your-tools",
    "href": "Day2_Prac5_landscapes.html#step-1-setup-gather-your-tools",
    "title": "5¬† üåã Creating Worlds",
    "section": "Step 1: Setup (Gather Your Tools)",
    "text": "Step 1: Setup (Gather Your Tools)\nBefore we build our world, let‚Äôs make sure we have the right tools. No one builds a universe without a hammer‚Ä¶ and a bunch of other R-packages.\n\n# Load the necessary libraries for plotting and data wrangling\nlib &lt;- c(\"terra\", \"raster\", \"lattice\", \"rayimage\", \"viridis\", \"gen3sis\", \"ggplot2\", \"persp\", \"here\")\nsapply(lib, require, character.only = TRUE, quietly = TRUE, warn.conflicts = TRUE)\n\n   terra   raster  lattice rayimage  viridis  gen3sis  ggplot2    persp \n    TRUE     TRUE     TRUE    FALSE     TRUE     TRUE     TRUE    FALSE \n    here \n    TRUE"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#step-2-declare-your-functions-make-your-tools",
    "href": "Day2_Prac5_landscapes.html#step-2-declare-your-functions-make-your-tools",
    "title": "5¬† üåã Creating Worlds",
    "section": "Step 2: Declare your functions (Make your tools)",
    "text": "Step 2: Declare your functions (Make your tools)\nNow that our libraries are ready, we need tools to help us generate the world. Below are custom functions to plot the terrain (plot_persp), simulate shape (drop and gaussian_2d), and generate random landscapes (random_landscape). These functions allow us to manipulate and visualize spatial grids with elevation data.\n\nplot_persp &lt;- function(x, y, z, lcol=topo.colors, ...) {\n  zz &lt;- (z[-1,-1] + z[-1,-ncol(z)] + z[-nrow(z),-1] + z[-nrow(z),-ncol(z)])/4\n  breaks &lt;- hist(zz, plot=FALSE)$breaks\n  cols &lt;- lcol(length(breaks)-1)\n  zzz &lt;- cut(zz, breaks=breaks, labels=cols)\n  persp(x, y, z, col=as.character(zzz),\n        phi=30, theta=-25, ltheta = -70,\n        expand = 0.5, border = NA, box = FALSE, shade = 0.75, ...)\n  # list(breaks=breaks)\n}\n\n\n# 'shape\n\ndrop &lt;- function(x,y, a=3, ...) { \n  r &lt;- sqrt(x^2+y^2)\n  # avoid zero division\n  r[r==0] &lt;- 1\n  z &lt;- a * sin(r)/r \n}\n\ngaussian_2d &lt;- function(x,y, x0, y0, sdx, sdy, a) { \n  r &lt;- (((x-x0)^2)/(2*sdx^2))+(((y-y0)^2)/(2*sdy^2))\n  z &lt;- a*exp(-r)\n  return(z)\n}\n\n# 'generator\n\nrandom_lanscape &lt;- function(x,y, n=2){\n  zf &lt;- 0\n  for (i in 1:n){\n  zf &lt;- zf+outer(x, y, gaussian_2d, x0=sample(x,1), y0=sample(y,1), sdx=rnorm(1,2,5), sdy=rnorm(1,2,5), a=rnorm(1,2,2))\n  }\n  return(zf)\n}\n\nset_landscape_t &lt;- function(x=seq(-10, 10, length=60),y=NA, t=-4:0, \n                            x0t=function(t){rep(0,length(t))}, \n                            y0t=function(t){rep(0,length(t))}, \n                            sdxt=function(t){2/(abs(t)+1)}, sdyt=NA, \n                            at=function(t){abs(t)+1}){\n  if (any(is.na(y))){y=x}\n  if (any(is.na(sdyt))){sdyt=sdxt}\n  l &lt;- list()\n  for (i in 1:length(t)){\n    ti &lt;- t[i]\n    l[[i]] &lt;- outer(x, y, gaussian_2d, x0=x0t(ti), y0=y0t(ti), sdx=sdxt(ti), sdy=sdyt(ti), a=at(ti))\n    names(l)[i] &lt;- paste0(\"x0=\",x0t(ti), \"|y0=\",y0t(ti), \"|sdx=\", sdxt(ti),\"|sdy=\",sdyt(ti),\"|a=\", at(ti))\n  }\n  return(l)\n}\n\nEvery world (i.e raster) needs a grid to hold it together. We will work without a coordinate system in a simple 1 unit grid. This will allow us to focus on the shape of the landscape without worrying about real-world problems (distortion).\n\n# size of the grid\nnlg &lt;- 1\n\n### single simple -----\nx &lt;- seq(-20, 20, by=nlg)\ny &lt;- x\nz &lt;- outer(x, y, gaussian_2d, x0=0, y0=0, sdx=2, sdy=2, a=10)\nplot_persp(x, y, z)\n\n\n\n\nNext, let‚Äôs make it funky‚Ä¶\nThe drop function can be used to create a terrain similar to an island by generating a peak that gradually descends towards the edges. This creates a radial pattern of decreasing elevation, much like a small volcanic island with surrounding lagoons. While this isn‚Äôt a very realistic model (Ask Tristan), its fun ü§ì.\n\n### single simple drop -----\nz &lt;- outer(x, y, drop, x0=20, y0=20, a=10)\nplot_persp(x, y, z)"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#build-your-own-tools-again-forget-about-steps",
    "href": "Day2_Prac5_landscapes.html#build-your-own-tools-again-forget-about-steps",
    "title": "5¬† üåã Creating Worlds",
    "section": "Build Your Own Tools Again, forget about steps‚Ä¶",
    "text": "Build Your Own Tools Again, forget about steps‚Ä¶\nThe process of creating and refining tools never stops in world-building. It would be nice to have a function to plot multiple landscapes no? Below is a function to plot multiple landscapes at different time steps in one visualization.\n\nplot_multiple_persp &lt;- function(l, lcol = topo.colors, scol = \"darkblue\", legend_title = \"Legend\", ...) {\n  # 'l' is the list of z values...\n  lv &lt;- do.call(c, l)\n  breaks &lt;- hist(lv, plot = FALSE)$breaks\n  cols &lt;- c(scol, lcol(length(breaks) - 2))\n  \n  # Save the original par settings\n  oldpar &lt;- par(no.readonly = TRUE)\n  on.exit(par(oldpar))\n  \n  # Number of subplots\n  times &lt;- length(l)\n  \n  # Dynamically define number of rows and columns for layout based on the number of steps\n  n_cols &lt;- ceiling(sqrt(times))  # Number of columns\n  n_rows &lt;- ceiling(times / n_cols)  # Number of rows\n  \n  # Set the plot margins: Adjust `mar` to make the plots closer to each other\n  par(mar = c(2, 2, 2, 2)*0.3)  # Reduce margins around each plot\n  \n  # Set the layout for the subplots (without extra row for legend)\n  par(mfrow = c(n_rows, n_cols))\n  \n  # Loop through the list of z-matrices and create the persp plots\n  for (i in seq_along(l)) {\n    zi &lt;- l[[i]]\n    zz &lt;- (zi[-1, -1] + zi[-1, -ncol(zi)] + zi[-nrow(zi), -1] + zi[-nrow(zi), -ncol(zi)]) / 4\n    zzz &lt;- cut(zz, breaks = breaks, labels = cols)\n    \n    # Plot each 3D surface with persp\n    persp(x, y, zi,\n          zlim = range(lv, na.rm = TRUE),\n          col = as.character(zzz),\n          phi = 30, theta = -25, ltheta = -70,\n          expand = 0.5, border = NA, box = FALSE, shade = 0.25, ...)\n    \n    # Add titles if names are available\n    if (!any(is.na(names(l)))) {\n      title(names(l)[i])\n    }\n    \n    # If it's the first plot, add a color scale (legend) on top of it\n    if (i == 1) {\n      # Use a small inset to add the legend (e.g., top-right corner)\n      legend(\"topright\", legend = round(breaks, 2), fill = cols, title = legend_title, cex = 0.7, inset = 0.05)\n    }\n  }\n}"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#add-more-islands",
    "href": "Day2_Prac5_landscapes.html#add-more-islands",
    "title": "5¬† üåã Creating Worlds",
    "section": "Add more islands!",
    "text": "Add more islands!\nIt‚Äôs time to create more complex terrains by adding multiple islands. We can simulate this by layering multiple Gaussian functions. In this example we will simply add the z values\n\npar(mfrow=c(1,3), mai=c(1,1,1,1)*0.3)\n# First island\nz1 &lt;- outer(x, y, gaussian_2d, x0=-10, y0=10, sdx=4, sdy=4, a=7)\nplot_persp(x, y, z1, main=\"z1\")\n\n# Second island\nz2 &lt;- outer(x, y, gaussian_2d, x0=10, y0=-10, sdx=5, sdy=6, a=5)\nplot_persp(x, y, z2, main=\"z2\")\n\n# Combine the two islands\nzf &lt;- z1 + z2\nplot_persp(x, y, zf, main=\"z1 + z2\")\n\n\n\n\nNow let‚Äôs use the same concept to create a time-evolving landscape with three islands. And see how the islands will grow and change over time.\n\n# Create a time-evolving landscape\nl &lt;- list(z1 = zf,\n          z2 = zf + outer(x, y, gaussian_2d, x0 = 0, y0 = -3, sdx = 2, sdy = 2.5, a = 3),\n          z3 = zf + outer(x, y, gaussian_2d, x0 = 0, y0 = -3, sdx = 2.5, sdy = 2.8, a = 4))\nplot_multiple_persp(l, lcol=terrain.colors)\n\n\n\n# Convert the landscapes to raster bricks\nrb &lt;- brick(lapply(l, raster))\nplot(rb)\n\n\n\n# Apply sea level cuts to the landscapes\nselev &lt;- c(1, 2, 1)\nls &lt;- l\nfor (zi in 1:3) {\n  ms &lt;- ls[[zi]] &lt;= selev[zi]\n  ls[[zi]][ms] &lt;- NA\n}\nrb &lt;- brick(lapply(ls, raster))\nplot(rb, col = viridis(255))"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#generating-a-landscape-with-multiple-peaks",
    "href": "Day2_Prac5_landscapes.html#generating-a-landscape-with-multiple-peaks",
    "title": "5¬† üåã Creating Worlds",
    "section": "5.2 Generating a Landscape with Multiple Peaks",
    "text": "5.2 Generating a Landscape with Multiple Peaks\nNow let‚Äôs generate a more complex landscape with multiple peaks to add more details to our world.\n\nnoise &lt;- random_lanscape(x, y, 80)\n# Few random peaks\nplot_persp(x, y, noise, main=\"Noise\")\n\n\n\n\nNow we add to our previous landscape\n\n# add to previous landscape\nplot_persp(x, y, noise/10+zf, main=\"Noise + zf\")\n\n\n\n\nPlay with it, it‚Äôs beautiful!\n\nplot_persp(x, y, (random_lanscape(x, y, 200)/10)+(zf), lcol=terrain.colors)"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#prepare-something-to-play-with",
    "href": "Day2_Prac5_landscapes.html#prepare-something-to-play-with",
    "title": "5¬† üåã Creating Worlds",
    "section": "Prepare something to play with",
    "text": "Prepare something to play with\nFor example, here we will use our previous more complex landscape and add 2 more islands\n\n# Set the radius of the circle and the number of points\nradius &lt;- 17  # For a circle within -20:20 range\nnum_points &lt;- 6\n\n# Generate equally spaced angles in radians\nangles &lt;- seq(0, 2*pi, length.out = num_points + 1)[-7]  # Exclude the last angle as it repeats the first\n\n# Compute x and y coordinates based on angles (x = cos(angle) * radius, y = sin(angle) * radius)\nx_values &lt;- radius * cos(angles)\ny_values &lt;- radius * sin(angles)\n\n# create islands using centroids as well as an island id mask for later\nisland_id &lt;- 0 # island id's\nelevation &lt;- 0 # elevation\n\n\nfor (island_i in 1:num_points){\n  # island_i &lt;- 1\n  z_i &lt;- outer(x, y, gaussian_2d, x0=x_values[island_i], y0=y_values[island_i], sdx=2, sdy=2, a=island_i*100) # times 100 for meter\n  # plot_persp(x, y, z_i, main=\"z_i\")\n  id_mask_temp &lt;- (z_i&gt;0.1)*island_i # this should be the lowest sealevel of all times\n  island_id &lt;- island_id+id_mask_temp\n  elevation &lt;- elevation+z_i\n}\nplot_persp(x,y, elevation)\n\n\n\n\nLike before, let‚Äôs add a temporal dynamics, without noise and just some sea level and temperature fluctuations. We will delay the sea level change by 1 time steps, as we expect the temperature to increase before the sea level rises.\n\n# define number of timesteps\nn_step &lt;- 24\n\n# cycles length in timesteps\ncycles_length &lt;- 5\n\n# delay\ndelay &lt;- 1\n\n# generate a sequence of values that oscillates between -1 and 1 (using sine function), a sine wave\noscillatory_values &lt;- sin(seq(0, 2*pi*cycles_length, length.out = n_step+delay))\n#plot(oscillatory_values, type=\"l\")\n\n# get the temperature and sea level values accounding for the delay\ntemp &lt;- tail(oscillatory_values, n_step)\nsealevel &lt;- head(oscillatory_values, n_step)\n\nplot(temp, type=\"l\", col=\"red\")\nlines(sealevel, col=\"blue\")\n\n\n\n# scale\nlimts &lt;- list(sealevel = c(1, 100), temperature = c(-2, 2))\n\n# function to scale oscillatory values to a given range\nscale_to_range &lt;- function(values, low, high) {\n  return (((values + 1) / 2) * (high - low) + low)\n}\n\n# apply the scaling to each element in the list\ntemp_vec &lt;- scale_to_range(temp, limts$temperature[1], limts$temperature[2])\nsealevel_vec &lt;- scale_to_range(sealevel, limts$sealevel[1], limts$sealevel[2])\n\nNow let‚Äôs change things though time and prepare out gen3sis input\n\nenv &lt;- list(elevation=list(), temp=list(), island_id=list())\n\n# temperature at absolute 0m\ntemp_abs &lt;- 27\n\nfor (t_i in 1:n_step){\n  # t_i &lt;- 1\n  # get matri of NA based on habitable sites (i.e. above sea level)\n  matrixNA &lt;- elevation\n  matrixNA[] &lt;- NA\n  matrixNA[elevation&gt;sealevel_vec[t_i]] &lt;- 1\n  #habitable_mask &lt;- elevation&gt;sealevel_vec[t_i]\n  # elevation\n  env$elevation[[t_i]] &lt;- elevation*matrixNA\n  # temp\n  # decrese temperature by 0.65¬∞C per 100 meters (mois)\n  env$temp[[t_i]] &lt;- (temp_abs+temp_vec[t_i]) - (env$elevation[[t_i]]/100)*0.65\n  # island id\n  env$island_id[[t_i]] &lt;- island_id*matrixNA\n}\n\nplot_multiple_persp(env$elevation, lcol=terrain.colors)\n\n\n\n# Convert the landscapes to raster bricks\nrball &lt;- lapply(env, function(xa){\n  revx &lt;- rev(xa) # rever to fit into data format... happy to hear your feedback here\n  lapply(revx, function(xaxa){\n    raster(xaxa, xmn=min(x)-0.5, xmx=max(x)+0.5, ymn=min(y)-0.5, ymx=max(y)+0.5)\n  })\n})\n\nOkay, our landscape is almoust ready to start getting some life on it! We will now prepare the gen3sis input using create_input_landscape, and run a simulation. We will use a config we prepared so that you can use it as a start and figure out what it is doing.\n\n# define cost function, crossing water as 4x as land sites\ncost_function_water &lt;- function(source, habitable_src, dest, habitable_dest) {\n  if(!all(habitable_src, habitable_dest)) {\n    return(4)\n  } else {\n    return(1)\n  }\n}\n\n\n# create a gen3sis input\ncreate_input_landscape(\n  landscapes = rball,\n  cost_function = cost_function_water,\n  output_directory = file.path(here(\"output/myworld\")),\n  directions = 8, # surrounding sites for each site\n  timesteps = paste0((n_step-1):0, \"step\"),\n  calculate_full_distance_matrices = TRUE,\n  verbose = T) # full distance matrix\n\n\nexp1 &lt;- run_simulation(\n  config = file.path(\"configs\", \"config_islands_simple_Day2Prac5.R\"),\n  landscape = file.path(here(\"output/myworld5\")),\n  output_directory = file.path(here(\"output/outputs\")),\n  verbose = 1\n)"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#conclusion",
    "href": "Day2_Prac5_landscapes.html#conclusion",
    "title": "5¬† üåã Creating Worlds",
    "section": "Conclusion",
    "text": "Conclusion\nCongratulations! You‚Äôve successfully created your own world, shaped its terrain, and even made life thrive. Your world may not be ready for civilization just yet, but don‚Äôt worry‚ÄîRome wasn‚Äôt built in a day either. Keep experimenting and refining your creation. Well done, master world-builder! üåç‚ú®"
  },
  {
    "objectID": "Day3_Prac6_sandbox.html",
    "href": "Day3_Prac6_sandbox.html",
    "title": "6¬† ü•™ Sandbox",
    "section": "",
    "text": "The aim for this practical is to try and take what you‚Äôve learned about how Gen3sis works and attempt to elaborate on the configs you have been already playing with. As a case study, and because there‚Äôs so many ways it could be possible to implement, we think it would be fun to try and implement different ways to test the Ecological Limits Hypothesis (ELH) in small groups.\n\n\n\n\n\n\nNote\n\n\n\nIf you have a particular hypothesis or case study you‚Äôd like to work on instead, let us know and we might be able to tailor this.\n\n\nThe day will be quite free-form and we‚Äôll be around to guide you, but a straight forward way to do this would be to:\n\nTake an existing landscape you have used already, such as South America or the simulated islands\nTake an existing config from day 1 (M1-M4)\nModify the existing config, probably in the ecology function, to implement the ELH\nRun the simulation, troubleshooting any errors you get along the way\nPlot out some key biodiversity patterns (like richness) and explore how they differ to the original config\n\nOf course, you don‚Äôt have to do the basic version of this prac, you might want to make more dramatic changes, such as by:\n\nUsing different landscapes - either simulating them following Day 2‚Äôs landscape modification prac, or from empirical data such as paleoenvironmenta data from Tristan‚Äôs work, future climate projections under climate change for terrestrial (CHELSA) or marine (Bio-oracle) systems, or recent historical climate change from the last glacial maximum to the present (LGM; CHELSA)\nCreating the whole config, or parts of it, from scratch. For example you may want to implement different models of trait evolution, or include different traits, different dispersal functions etc. You are not limited to the configs we have provided!"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#step-3-create-a-dynamic-landscape",
    "href": "Day2_Prac5_landscapes.html#step-3-create-a-dynamic-landscape",
    "title": "5¬† üåã Creating Worlds",
    "section": "Step 3: Create a dynamic landscape",
    "text": "Step 3: Create a dynamic landscape\nNow, let‚Äôs make it dynamic! Here we use time (ti) as the input to dynamically adjust the standard deviation in the Gaussian function. Our temporal unit is time-step and cells are our spacial units.\n\n### multiple -----\nl &lt;- list()\nfor (ti in 1:6){ # set the number of time steps\n  l[[ti]] &lt;- outer(x, y, gaussian_2d, x0=0, y0=0, sdx=ti, sdy=ti, a=ti^-0.8)\n  # add constant sea level\n  l[[ti]][l[[ti]]&lt;0.1] &lt;- 0.1\n}"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#see-the-landscape-youve-crafted-take-shape-in-all-its-3d-glory",
    "href": "Day2_Prac5_landscapes.html#see-the-landscape-youve-crafted-take-shape-in-all-its-3d-glory",
    "title": "5¬† üåã Creating Worlds",
    "section": "See the landscape you‚Äôve crafted take shape in all its 3D glory",
    "text": "See the landscape you‚Äôve crafted take shape in all its 3D glory\nUse your new tool to visualize the dynamic landscape you‚Äôve created.\n\nplot_multiple_persp(l, lcol=terrain.colors)"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#random-landscapes",
    "href": "Day2_Prac5_landscapes.html#random-landscapes",
    "title": "5¬† üåã Creating Worlds",
    "section": "Random Landscapes",
    "text": "Random Landscapes\nNow let‚Äôs generate a more complex landscape with multiple peaks to add more details to our world.\n\nnoise &lt;- random_lanscape(x, y, 20)\n# Few random peaks\nplot_persp(x, y, noise, main=\"Noise\")\n\n\n\n\nNow we add to our previous landscape\n\n# add to previous landscape\nplot_persp(x, y, (noise/10)+zf, main=\"Noise + zf\")\n\n\n\n\nExperiment with it; there‚Äôs a lot of room when creativity your own world!\n\nplot_persp(x, y, (random_lanscape(x, y, 200)/10)+(zf), lcol=terrain.colors)"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#creating-an-archipelago",
    "href": "Day2_Prac5_landscapes.html#creating-an-archipelago",
    "title": "5¬† üåã Creating Worlds",
    "section": "Creating an Archipelago",
    "text": "Creating an Archipelago\nLet‚Äôs create an archipelago with multiple islands. We will use the same concept as before, but this time we will add more islands to the landscape. I.e 6, starting from the smallest to the largest island all spread evenly in a circle.\n\n# Set the radius of the circle and the number of points\nradius &lt;- 17  # For a circle within -20:20 range\nnum_points &lt;- 6\n\n# Generate equally spaced angles in radians\nangles &lt;- seq(0, 2*pi, length.out = num_points + 1)[-7]  # Exclude the last angle as it repeats the first\n\n# Compute x and y coordinates based on angles (x = cos(angle) * radius, y = sin(angle) * radius)\nx_values &lt;- radius * cos(angles)\ny_values &lt;- radius * sin(angles)\n\n# create islands using centroids as well as an island id mask for later\nisland_id &lt;- 0 # island id's\nelevation &lt;- 0 # elevation\n\n\nfor (island_i in 1:num_points){\n  # island_i &lt;- 1\n  z_i &lt;- outer(x, y, gaussian_2d, x0=x_values[island_i], y0=y_values[island_i], sdx=2, sdy=2, a=island_i*100) # times 100 for meter\n  # plot_persp(x, y, z_i, main=\"z_i\")\n  id_mask_temp &lt;- (z_i&gt;0.1)*island_i # this should be the lowest sealevel of all times\n  island_id &lt;- island_id+id_mask_temp\n  elevation &lt;- elevation+z_i\n}\nplot_persp(x,y, elevation)\n\n\n\n\nLike before, let‚Äôs add a temporal dynamics and sea level and temperature fluctuations. We will use a sine wave to simulate temperature and sea level changes over time. We will delay the sea level change by 1 time steps, as we expect the temperature to increase before the sea level rises.\n\n# define number of timesteps\nn_step &lt;- 24\n\n# cycles length in timesteps\ncycles_length &lt;- 5\n\n# delay\ndelay &lt;- 1\n\n# generate a sequence of values that oscillates between -1 and 1 (using sine function), a sine wave\noscillatory_values &lt;- sin(seq(0, 2*pi*cycles_length, length.out = n_step+delay))\n#plot(oscillatory_values, type=\"l\")\n\n# get the temperature and sea level values accounding for the delay\ntemp &lt;- tail(oscillatory_values, n_step)\nsealevel &lt;- head(oscillatory_values, n_step)\n\nplot(temp, type=\"l\", col=\"red\")\nlines(sealevel, col=\"blue\")\n\n\n\n# scale\nlimts &lt;- list(sealevel = c(1, 100), temperature = c(-2, 2))\n\n# function to scale oscillatory values to a given range\nscale_to_range &lt;- function(values, low, high) {\n  return (((values + 1) / 2) * (high - low) + low)\n}\n\n# apply the scaling to each element in the list\ntemp_vec &lt;- scale_to_range(temp, limts$temperature[1], limts$temperature[2])\nsealevel_vec &lt;- scale_to_range(sealevel, limts$sealevel[1], limts$sealevel[2])\n\nNow let‚Äôs apply these changes over time to our landscape.\n\nenv &lt;- list(elevation=list(), temp=list(), island_id=list())\n\n# temperature at absolute 0m\ntemp_abs &lt;- 27\n\nfor (t_i in 1:n_step){\n  # t_i &lt;- 1\n  # get matri of NA based on habitable sites (i.e. above sea level)\n  matrixNA &lt;- elevation\n  matrixNA[] &lt;- NA\n  matrixNA[elevation&gt;sealevel_vec[t_i]] &lt;- 1\n  #habitable_mask &lt;- elevation&gt;sealevel_vec[t_i]\n  # elevation\n  env$elevation[[t_i]] &lt;- elevation*matrixNA\n  # temp\n  # decrese temperature by 0.65¬∞C per 100 meters (mois)\n  env$temp[[t_i]] &lt;- (temp_abs+temp_vec[t_i]) - (env$elevation[[t_i]]/100)*0.65\n  # island id\n  env$island_id[[t_i]] &lt;- island_id*matrixNA\n}\n\nplot_multiple_persp(env$elevation, lcol=terrain.colors)\n\n\n\n# Convert the landscapes to raster bricks\nrball &lt;- lapply(env, function(xa){\n  revx &lt;- rev(xa) # rever to fit into data format... happy to hear your feedback here\n  lapply(revx, function(xaxa){\n    raster(xaxa, xmn=min(x)-0.5, xmx=max(x)+0.5, ymn=min(y)-0.5, ymx=max(y)+0.5)\n  })\n})"
  },
  {
    "objectID": "Day2_Prac5_landscapes.html#prepare-gen3sis-input",
    "href": "Day2_Prac5_landscapes.html#prepare-gen3sis-input",
    "title": "5¬† üåã Creating Worlds",
    "section": "Prepare gen3sis input",
    "text": "Prepare gen3sis input\nOkay, our landscape is almost ready to start getting some life on it! We will now prepare the gen3sis input using create_input_landscape, and run a simulation. We will use a config we prepared so that you can use it as a start and figure out what it is doing.\n\n# define cost function, crossing water as 4x as land sites\ncost_function_water &lt;- function(source, habitable_src, dest, habitable_dest) {\n  if(!all(habitable_src, habitable_dest)) {\n    return(4)\n  } else {\n    elev_diff &lt;- 1-(source[\"elevation\"] - dest[\"elevation\"])/600\n    return(elev_diff)\n  }\n}\n\n\n# create a gen3sis input\ncreate_input_landscape(\n  landscapes = rball,\n  cost_function = cost_function_water,\n  output_directory = file.path(here(\"data/landscapes/hard_to_climb_easy_to_roll\")),\n  directions = 8, # surrounding sites for each site\n  timesteps = paste0((n_step-1):0, \"step\"),\n  calculate_full_distance_matrices = TRUE,\n  verbose = T,\n  overwrite_output = T) # full distance matrix\n\n\nexp1 &lt;- run_simulation(\n  config = file.path(\"configs\", \"config_islands_simple_Day2Prac5.R\"),\n  landscape = file.path(here(\"data/landscapes/myworld\")),\n  output_directory = file.path(here(\"output/outputs\")),\n  verbose = 1\n)"
  },
  {
    "objectID": "considerations.html",
    "href": "considerations.html",
    "title": "7¬† üëª Important considerations",
    "section": "",
    "text": "7.0.1 Paleo-environmental data\nInvestigations of deep-time paleoclimatic influences on biodiversity are still limited by our current mechanistic knowledge of eco-evolutionary processes and by computational power, as well as by the availability of paleo-environmental reconstructions (Svenning et al., 2015, Franklin et al., 2017, Pontarp et al., 2019). Biodiversity dynamics and climatic variations happening on smaller spatio-temporal scales have to be ignored due to the uncertainty in paleo-landscape reconstructions.\n\n\n7.0.2 Distribution, fossil and phylogenetic data\nBiodiversity data is of the essence when evaluating implemented processes of eco-evolutionary models with empirical biodiversity patterns. In order to perform the evaluation, multiple past and present biological empirical datasets can be used, such as: (i) fossil records, (ii) calibrated molecular phylogenies, (iii) population genetic data, (iv) trait measurements, and (v) species distribution maps. The combination of multiple datasets, such as phylogenies and fossils, provides a better picture of past dynamic processes (Huang et al., 2015, Hagen et al., 2018, Coiro et al., 2019). The main gaps remaining in biodiversity data, as pointed out in multiple studies (Franklin, 2010, Hampton et al., 2015, Meyer et al., 2016), are: (i) sparse data with regional biases, (ii) a lack of non-occurrence data reporting, (iii) poor availability of public data, and (iv) high heterogeneity in data quality and methodologies.\n\n\n7.0.3 Model complexity\nThe modelling engine gen3sis introduced here is predominantly a theoretical model rather than exclusively a calculating tool, since responses from possible natural processes are predicted (Guisan and Zimmermann, 2000). By prioritizing theoretical correctness of the predicted response over predicted precision, a spatio-temporal mechanistic model was created in the most flexible way possible in order to explore multiple hypotheses and processes.\n\n\n7.0.4 Computational time\nRuntimes are heavily dependent on the number of species emerging during a simulation and their geographical extent, and thus are highly dependent on the assumed model parameters and input landscape. The current state of optimizations is limited because no parallelization is implemented, as ease of maintenance and development are prioritized for this initial release.\n\n\n7.0.5 Core functions\nGiven the inherent computational limitations, gen3sis tries to incorporate all the processes at the level of geographical ranges of populations, as realistically as possible. However, the modelled objects are limited to geographic populations and species. Also, it is not possible to track cluster phylogenies. Moreover, there is no within-cell variation within a species.\n\n\n7.0.6 Caveats\n\ntemporal behaviour: No variables in gen3sis have an explicit temporal component. It is always x/timestep. That means that most processes will either speed up or slow down if one changes the temporal resolution of the input. For example, a configured rate of dispersal of 1/timestep can become 10/million years or 2/million years for simulations with 10 and 2 timesteps per million years respectively.\nraster inputs: The behaviour of the species dispersal and geographic clustering depends on the spatial input resolution. Changing input resolution can have secondary effects. For example, a higher-resolution landscape input will have more cells. Not only will it be easier to reach neighbouring cells, but there will also be more chances for dispersal events to happen. As such there might be a non-linear dependency between dispersal values and input resolution.\npolar distortions: Our distance calculations correct for the distance distortions raster-based data experiences towards the polar regions. This does lead to many small cells being close together in the polar regions. This makes dispersal a lot easier compared to equatorial cells in two ways. First, the dispersal distances are often enough to reach multiple neighbours. And second, since there are many more cells closed by, more dispersal events can happen."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "8¬† üí´ Further Resources",
    "section": "",
    "text": "CRAN\n\nPackage\nManual\n\n\n\nVignettes\n\nIntroducing Gen3sis\nCreating landscapes (gen3sis input)\nCreating configurations (gen3sis input)\nExample designing landscapes\n\n\n\nPrevious Workshops\n\nMS3BM (2022, iDiv, Leipzig)\nYOMOS (2023)\n\n\n\nEcosystems & Landscape Ecology Group\n\nWiki\n\n\n\nPapers\n\nHagen, O., Fl√ºck, B., Fopp, F., Cabral, J.S., Hartig, F., Pontarp, M., Rangel, T.F. and Pellissier, L., 2021. gen3sis: A general e ngine for e co-e volutionary si mulation s of the processes that shape Earth‚Äôs biodiversity. PLoS Biology, 19(7), p.e3001340.\nHagen, O., Skeels, A., Onstein, R.E., Jetz, W. and Pellissier, L., 2021. Earth history events shaped the evolution of uneven biodiversity across tropical moist forests. Proceedings of the National Academy of Sciences, 118(40), p.e2026347118.\nLeugger, F., Broquet, T., Karger, D.N., Rioux, D., Buzan, E., Corlatti, L., Crestanello, B., Curt‚ÄêGrand‚ÄêGaudin, N., Hauffe, H.C., Roleƒçkov√°, B. and ≈†prem, N., 2022. Dispersal and habitat dynamics shape the genetic structure of the Northern chamois in the Alps. Journal of Biogeography, 49(10), pp.1848-1861.\nHagen, O., 2023. Coupling eco‚Äêevolutionary mechanisms with deep‚Äêtime environmental dynamics to understand biodiversity patterns. Ecography, 2023(4), p.e06132.\nSkeels, A., Bach, W., Hagen, O., Jetz, W. and Pellissier, L., 2023. Temperature-dependent evolutionary speed shapes the evolution of biodiversity patterns across tetrapod radiations. Systematic Biology, 72(2), pp.341-356.\nSkeels, A., Boschman, L.M., McFadden, I.R., Joyce, E.M., Hagen, O., Jim√©nez Robles, O., Bach, W., Boussange, V., Keggin, T., Jetz, W. and Pellissier, L., 2023. Paleoenvironments shaped the exchange of terrestrial vertebrates across Wallace‚Äôs Line. Science, 381(6653), pp.86-92.\nBoschman, L.M., Carraro, L., Cassemiro, F.A., de Vries, J., Altermatt, F., Hagen, O., Hoorn, C. and Pellissier, L., 2023. Freshwater fish diversity in the western Amazon basin shaped by Andean uplift since the Late Cretaceous. Nature Ecology & Evolution, 7(12), pp.2037-2044.\nSkeels, A., Esquerr√©, D., Lipsky, D., Pellissier, L. and Boschman, L.M., 2023. Elevational Goldilocks zone underlies the exceptional diversity of a large lizard radiation (Liolaemus; Liolaemidae). Evolution, 77(12), pp.2672-2686.\nKeggin, T., Waldock, C., Skeels, A., Hagen, O., Albouy, C., Manel, S. and Pellissier, L., 2023. Diversity across organisational scale emerges through dispersal ability and speciation dynamics in tropical fish. BMC biology, 21(1), p.282.\nRogger, J., Mills, B.J., Gerya, T.V. and Pellissier, L., 2024. Speed of thermal adaptation of terrestrial vegetation alters Earth‚Äôs long-term climate. Science Advances, 10(9), p.eadj4408.\nHagen, O., Viana, D.S., Wiegand, T., Chase, J.M. and Onstein, R.E., 2024. The macro-eco-evolutionary interplay between dispersal, competition and landscape structure in generating biodiversity. Philosophical Transactions B, 379(1907), p.20230140.\nRogger, J., Judd, E.J., Mills, B.J., Godd√©ris, Y., Gerya, T.V. and Pellissier, L., 2024. Biogeographic climate sensitivity controls Earth system response to large igneous province carbon degassing. Science, 385(6709), pp.661-666."
  }
]