[
  {
    "objectID": "program.html",
    "href": "program.html",
    "title": "1¬† Program",
    "section": "",
    "text": "Day 1.\n\n9:00 - Welcome (Platypus Room) - Introductions and Overview of Gen3sis Workshop\n9:45 - Lecture 1. Oskar Hagen (Eucalyptus Room) - History and philosophy of simulation modelling in biodiversity studies\n10:45 - Coffee Break\n11:00 - Practical 1. Installation and Set Up (30mins - 1hr)\n12pm - Practical 2. Gen3sis Config Basics\n12:00 - Lunch Break\n1:30 - Practical 2. Gen3sis Config Basics (continue - 2hrs)\n15:30 - Coffee Break\n15:45pm - Guided Exercise 1. Explore island configs\n16:30 - Questions / Warp up Day 1\n\n\n\nDay. 2\n\n9am - Lecture 2. Alex and Oskar - Inference from biodiversity data\n10:00 - Practical 3.1. Gen3sis outputs and biodiversity patterns\n10:30 - Coffee Break\n10:45 - Practical 3.2 Gen3sis outputs and biodiversity patterns (contd.)\n12:30 - lunch\n13:30 - Lecture 3. Tristan Salles ‚Äì Paleoenvironmental models and data\n14:15 - Discussion\n14:45 - Coffee break\n15:00 - Practical 4. Modifying landscapes for Gen3sis\n16:30 - Questions / Wrap up Day 2\n\n\n\nDay 3.\n\n09:00 - Lecture 4. Alex and Oskar - Designing simulation experiments with Gen3sis\n10:00 Group work - implementing models in Gen3sis\n10:30 - Coffee Break\n10:45 - Group work - implementing models in Gen3sis (contd.)\n12:30 - Lunch break\n13:30 - Wrapping up Group work\n14:45 - Coffee Break\n15:00 - Presenting models and warp up Day 3\n16:00 - Pub",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Program</span>"
    ]
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "2¬† Installation and set up",
    "section": "",
    "text": "The first bottleneck for any workshop is getting the software installed and running on everyone‚Äôs machine. So we‚Äôll spend a few minutes here making sure we‚Äôre all good with installing and taking a look at some of teh data we‚Äôll be working with during the workshop, before moving on to the nitty gritty. So, lets start by installing the Gen3sis R package.\nYou can install the package directly from CRAN as follows.\n\ninstall.packages(\"gen3sis\")\npackageVersion(\"gen3sis\")\n\nToday we‚Äôll install the most recent version of the package from GitHub using devtools.\n\ninstall.packages(\"devtools\")\ndevtools::install_github(repo = \"project-gen3sis/R-package\", dependencies = TRUE)\nlibrary(gen3sis)\npackageVersion(\"gen3sis\")\n\nAll the data for the workshop is stored in the ‚Äòdata‚Äô folder.\n\ndata_dir &lt;- \"data\"\n\nIn this fodler we include a paleoenvironmental reconstruction of South American temperature and aridity at a coarse spatial resolution of 2 degrees, and at a temporal resolution of 1 million years. Load it in and investigate some of it‚Äôs features.\n\n# read the R data file\nlandscape &lt;- readRDS(file.path(data_dir,\"landscapes\", \"SA_coarse\", \"landscapes.rds\"))\n\n# class\nclass(landscape)\n\n# names\nnames(landscape)\n\n# dimensions\ndim(landscape$temp)\n\n# take a look at first elements\nlandscape$temp[1:10, 1:10]\n\n# column names\ncolnames(landscape$temp)\n\nCoolies. We can use different spatial R packages to play with our data, and later on, with our simulated output. Parts of gen3sis package use raster, however this package is now depreciated, so we‚Äôll use terra except where stated. Ideally, you‚Äôll install both.\n\ninstall.packages(\"terra\")\ninstall.packages(\"raster\")\n\nlibrary(terra)\n\n# Present Day South America\nSA_1 &lt;- rast(landscape$temp[ ,c(\"x\", \"y\", \"1\")])\nSA_65 &lt;- rast(landscape$temp[,c(\"x\", \"y\", \"65\")])\n\n# plot present day\nplot(SA_1)\n\n\n# plot 65 Million years ago\nplot(SA_65)\n\nLets overlay the maps to get an idea of how much South America has changed since the dinosaurs went extinct.\n\n# overlay\nplot(SA_65, col=rgb(1,0,0))\nplot(SA_1, col=rgb(0,0,1,0.5,1), add=T)\n\nLoad in a config file containing the rules and parameters of a single simulation. We‚Äôll get into what this all means next chapter.\n\nconfig_dir &lt;- \"configs/SouthAmerica\"\nconfig &lt;- create_input_config(config_file = file.path(config_dir, \"config_southamerica.R\"))\nnames(config$gen3sis)\nnames(config$gen3sis$general)\n\nNow time to run a simulation in South America. We‚Äôll just run from 20 million years ago to the present-day at 1 million year intervals so it runs quick enough to finish in a couple of minutes. Note the output as it runs. Think about what its printing.\n\nsim &lt;- run_simulation(config = file.path(config_dir, \"config_southamerica.R\"), \n               landscape = file.path(data_dir,\"landscapes\", \"SA_coarse\"),\n               output_directory = \"output/SouthAmerica\",\n               verbose=1)\n\nIf you‚Äôve made it this far, great! You‚Äôre equipped with the tools, now we‚Äôre ready to explore how Gen3sis works in more detail.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Installation and set up</span>"
    ]
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "3¬† Config Basics",
    "section": "",
    "text": "To begin the dive into what Gen3sis is, and how it operates, we‚Äôll start by looking a config file. The config is the code for the ecological and evolutionary rules and other parameters of Gen3sis, such as the random see, instructions on saving output, etc.\nA config file is a a stand-alone R script which is modified by you. We can generate a new blank config file automatically to specified location in your configs folder and open it in R. Give that try.\n\nwrite_config_skeleton(\"configs/blank_config\")\n\nOnce you‚Äôve got the hang of Gen3sis it‚Äôs straightforward to populate these with functions. However, for now, lets start with the config we used in the previous section. We should still have that config loaded in our workspaces, but if not run this code.\n\nconfig_dir &lt;- \"configs/SouthAmerica\"\nconfig &lt;- create_input_config(config_file = file.path(config_dir, \"config_southamerica.R\"))\n\nlets take a look at the config\n\nconfig\n\nOh boy, that‚Äôs intimidating. But, don‚Äôt stress, we‚Äôll go through it piece by piece and learn what each bit is doing.\n\nstr(config)\nnames(config)\n\nWe can see that the config is a list with 3 components: 1. gen3sis, 2. user, 3. directories. For now, we‚Äôll focus on gen3sis which is the meat of the config. This ‚Äògen3sis‚Äô element itself is a list of 6 elements: ‚Äògeneral‚Äô, ‚Äòinitialization‚Äô, ‚Äòdispersal‚Äô, ‚Äòspeciation‚Äô,‚Äòmutation‚Äô, and ‚Äòecology‚Äô.\n\nnames(config$gen3sis)\n\n\nGeneral\nThe first element, ‚Äògeneral‚Äô, sets up some important global parameters of the model\n\nconfig$gen3sis$general\n\nThe random seed determines the starting point for random number generators in R. Because the simulations have stochastic processes, to reproduce a result, we need to have the same random seed, so by fixing it in a simulation, we can ensure we will get the exact same results next time we run the sim. Let‚Äôs change the seed to 777.\n\nconfig$gen3sis$general$random_seed\n\nconfig$gen3sis$general$random_seed &lt;- 777\n\nThe start time is the time-step of the landscape file which the simulation will start at. We saw in the previous chapter that the South American landscape file had 65 time-steps, but we actually only started our simulation at time-step 20, or 20 time-steps before the final one. Each time-step in the landscape is 1 million years apart, so the timestep 20 is 20 million years ago. However, if the landscape units were in 100 thousand years, then time-step 20 would be 2 million years ago. Let‚Äôs run the next simulation from an older timepoint, lets say the start of the Oligocene, 34 Ma.\n\nconfig$gen3sis$general$start_time\n\nconfig$gen3sis$general$start_time &lt;- 34\n\nOur simulation ran from 20 Ma to the present-day. However, we may wish for the simulation to finish before the present-day, for example just the Oligocene period 34Ma - 23Ma. To do this we can change the ‚Äòend_time‚Äô. When left as NA, the simulation will run to the final time-step. So let‚Äôs change that to 23 Ma.\n\nconfig$gen3sis$general$end_time\n\nconfig$gen3sis$general$end_time &lt;- 23\n\n#Initialization {.unnumbered} The first step of any simulation is to populate your landscape with one or more species and assign them traits. This includes geographic distribution, types of traits to be implemented, and values for those traits. Every species in the simulation is stored in a list and consists of an ID, their abundance, trait values, and intraspecies divergence values.\n\n\nDispersal (migration)\nHow species disperse across the landscape is determined by simulated migration events between habitable cells. The range and behaviour of these events is set by users and can be based on fixed values, draws from probability distributions, species trait values, or anything else thought up by users.\n\n\nSpeciation (population divergence)\nThe speciation function determines how you want new species to form. This is based on a divergence counter and speciation threshold. Once two clusters within a species diverge enough to reach the speciation threshold, a new species forms. How the counter behaves is entirely up to users!\n\n\nMutation (trait evolution)\nEach species can have traits set by users. This function provides the opportunity to modify or ‚Äúmutate‚Äù these traits with each time step in the simulation. How these traits change (or not) is entirely customisable.\n\n\nEcology (interactions)\nEvery species present in a cell across the landscape has an abundance value representing the population size of the species in that location. The ecology function allows users to modify this abundance value based on environmental values, species interactions, or anything else relevant to the study. An abundance of 0 leads to the extinction of the species in that cell.\n\noutput_dir &lt;- \"output/SouthAmerica\"\nsim &lt;- readRDS(file.path(output_dir, \"config_southamerica/sgen3sis.rds\"))\nnames(sim)\n\n\n\n#### Visualize --------------- \n#the outputs\nplot_summary(sim)\n\n# using raster package\nplot(rasterFromXYZ(sim$summary$`richness-final`))\n\nplot(rasterFromXYZ(sim$summary$`richness-final`), col=gen3sis::color_richness(10))\n\n\n# plot diversity at 3 time slices\ntimesteps &lt;- c(40, 20, 0)\npar(mfrow = c(1, 3))\nfor (i in timesteps) {\n  landscape_i &lt;- readRDS(file.path(output_dir, paste0(\"config_southamerica/landscapes/landscape_t_\", \n                                                    i, \".rds\")))\n  species_i &lt;- readRDS(file.path(output_dir, paste0(\"config_southamerica/species/species_t_\", \n                                                  i, \".rds\")))\n  plot_richness(species_i, landscape_i)\n}\ndev.off()",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Config Basics</span>"
    ]
  },
  {
    "objectID": "output.html",
    "href": "output.html",
    "title": "4¬† Output",
    "section": "",
    "text": "The simulation output has several components which together, or seperately, allow for all kinds of analyses of resulting biodiversity patterns.\n\n5 Generate presence-absence matrix\nA presence/absence matrix is a commonly used format for performing ecological analyses, such as PD/MPD/MNTD in the picante package.\n# first set the directory to the output folder   # then load in landscape and species obejct at the final timestep (will work for any timestep) setwd(\"landscapes\") landscape &lt;- readRDS(\"landscape_t_0.rds\")  setwd(\"../species\") species &lt;- readRDS(\"species_t_0.rds\")  # grid cell names all_cells &lt;- rownames(landscape$coordinates)  # get 0 for absence and 1 for presence in each grid cell all_species_presence &lt;- do.call( cbind, lapply(species, FUN = function(x) {ifelse(all_cells %in% names(x$abundance), 1, 0)}))  # colnames are species names colnames(all_species_presence ) &lt;- unlist(lapply(species, function(x){x$id}))  # column bind with x/y coordinates  presence_absence_matrix &lt;- cbind(landscape$coordinates, all_species_presence)\n\n\n6 Calculate taxonomic & phylogenetic diversity\nThe first step in your analysis could for instance be to calculate mean species richness per grid cell.\n# read in the richness object for the desired timestep richness &lt;- readRDS(\"richness_t_0.rds\")) richness_mean &lt;- mean(richness, na.rm=T)  \nThen you might want to look at indices of phylogenetic diversity.\n# read in the phylogeny for the desired timestep phy &lt;- try(read.nexus(\"phylogeny_t_0.nex\")))  # to make the simulations comparable, you should probably rescale each of them using the following function  rescaleTree&lt;-function(tree,scale){   tree$edge.length&lt;-     tree$edge.length/max(nodeHeights(tree)[,2])*scale   return(tree) }  phy &lt;- rescaleTree(phy, 1)  # now that you have a presence-absence matrix, you can calculate phylogenetic community  # metrics like Faith's PD, MPD, and MNTD  pd_estimate &lt;- pd.query(phy, presence_absence_matrix, standardize = T) mpd_estimate &lt;- mpd.query(phy, presence_absence_matrix, standardize = T) mntd_estimate &lt;- mpd.query(phy, presence_absence_matrix, standardize = T)\n\n\n7 Calculate functional diversity\nOne amazing feature of gen3sis is the possibility to let traits evolve with your simulation. The traits are defined in your core functions and can be anything, temperature niche, body size, or the number of limbs. The world is your oyster! To draw meaningful conclusions from your experiment you might have to\n# load in the traits from the desired time step traits &lt;- readRDS(\"traits_t_0.rds\"))  # transform from a list into a readable vector   temp_trait_means &lt;- unlist(lapply(traits, FUN=function(x){y=mean(x[,\"temp\"], na.rm=T);return(y)})) # this is the temperature niche    bs_trait_means &lt;- unlist(lapply(traits, FUN=function(x){y=mean(x[,\"body_size\"], na.rm=T);return(y)})) # and this represents bodysize   # exploring different summary statistics of the same metrics  temp_mean&lt;- mean(temp_trait_means, na.rm=T) # mean temp niche  temp_sd &lt;- sd(temp_trait_means, na.rm=T) # sd temp niche  temp_skewness[i] &lt;- skewness(temp_trait_means, na.rm=T)     bs_mean&lt;- mean(bs_trait_means, na.rm=T) # mean temp niche  bs_sd &lt;- sd(bs_trait_means, na.rm=T) # sd temp niche\n\n\n8 Calculate batch of spatial, phylogenetic, and functional metrics\nThis script calculates a set of 53 summary statistics used in Skeels et al (2021) and gives an example of, not only how to calculate a variety of different metrics, but also how to do so on a large batch of simulations (here we loop over the output folders of 500 simulations).\n\n\n9 Calculate diversification rates through space and time\nThis script calculates speciation rates and extinction at each time step and also summarises speciation rates and extinction by both temperature and latitude to understand the spatial variation in diversification rates.\n\n\n10 Calculate phylogenetic and weighted endemisms\nThis script calculates phylogenetic and weighted endemism from simulated data.\n\n\n11 Standalone functions\nAnother way of organizing analysis tools is to have a set of functions similar to an R package that can be called in various scripts. Here is a set of various example functions to use / look through.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Output</span>"
    ]
  },
  {
    "objectID": "considerations.html",
    "href": "considerations.html",
    "title": "5¬† Considerations",
    "section": "",
    "text": "5.0.1 Paleo-environmental data\nInvestigations of deep-time paleoclimatic influences on biodiversity are still limited by our current mechanistic knowledge of eco-evolutionary processes and by computational power, as well as by the availability of paleo-environmental reconstructions (Svenning et al., 2015, Franklin et al., 2017, Pontarp et al., 2019). Biodiversity dynamics and climatic variations happening on smaller spatio-temporal scales have to be ignored due to the uncertainty in paleo-landscape reconstructions.\n\n\n5.0.2 Distribution, fossil and phylogenetic data\nBiodiversity data is of the essence when evaluating implemented processes of eco-evolutionary models with empirical biodiversity patterns. In order to perform the evaluation, multiple past and present biological empirical datasets can be used, such as: (i) fossil records, (ii) calibrated molecular phylogenies, (iii) population genetic data, (iv) trait measurements, and (v) species distribution maps. The combination of multiple datasets, such as phylogenies and fossils, provides a better picture of past dynamic processes (Huang et al., 2015, Hagen et al., 2018, Coiro et al., 2019). The main gaps remaining in biodiversity data, as pointed out in multiple studies (Franklin, 2010, Hampton et al., 2015, Meyer et al., 2016), are: (i) sparse data with regional biases, (ii) a lack of non-occurrence data reporting, (iii) poor availability of public data, and (iv) high heterogeneity in data quality and methodologies.\n\n\n5.0.3 Model complexity\nThe modelling engine gen3sis introduced here is predominantly a theoretical model rather than exclusively a calculating tool, since responses from possible natural processes are predicted (Guisan and Zimmermann, 2000). By prioritizing theoretical correctness of the predicted response over predicted precision, a spatio-temporal mechanistic model was created in the most flexible way possible in order to explore multiple hypotheses and processes.\n\n\n5.0.4 Computational time\nRuntimes are heavily dependent on the number of species emerging during a simulation and their geographical extent, and thus are highly dependent on the assumed model parameters and input landscape. The current state of optimizations is limited because no parallelization is implemented, as ease of maintenance and development are prioritized for this initial release.\n\n\n5.0.5 Core functions\nGiven the inherent computational limitations, gen3sis tries to incorporate all the processes at the level of geographical ranges of populations, as realistically as possible. However, the modelled objects are limited to geographic populations and species. Also, it is not possible to track cluster phylogenies. Moreover, there is no within-cell variation within a species.\n\n\n5.0.6 Caveats\n\n\ntemporal behaviour: No variables in gen3sis have an explicit temporal component. It is always x/timestep. That means that most processes will either speed up or slow down if one changes the temporal resolution of the input. For example, a configured rate of dispersal of 1/timestep can become 10/million years or 2/million years for simulations with 10 and 2 timesteps per million years respectively.\n\nraster inputs: The behaviour of the species dispersal and geographic clustering depends on the spatial input resolution. Changing input resolution can have secondary effects. For example, a higher-resolution landscape input will have more cells. Not only will it be easier to reach neighbouring cells, but there will also be more chances for dispersal events to happen. As such there might be a non-linear dependency between dispersal values and input resolution.\n\npolar distortions: Our distance calculations correct for the distance distortions raster-based data experiences towards the polar regions. This does lead to many small cells being close together in the polar regions. This makes dispersal a lot easier compared to equatorial cells in two ways. First, the dispersal distances are often enough to reach multiple neighbours. And second, since there are many more cells closed by, more dispersal events can happen.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Considerations</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Center for Biodiversity Analysis: Gen3sis Workshop 2024",
    "section": "",
    "text": "Welcome!\nWelcome to the CBA sponsored workshop on the Gen3sis biodiversity simulation software. We‚Äôll be using this Quarto book to navigate through the workshop. Quarto allows us to embed R code throughout.\n\n1 + 1\n\n[1] 2",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "Day2_Prac4_outputs.html",
    "href": "Day2_Prac4_outputs.html",
    "title": "5¬† Day2_Prac3_Outputs",
    "section": "",
    "text": "6 Oututs\n{r} output_dir &lt;- \"output/SouthAmerica\" sim &lt;- readRDS(file.path(output_dir, \"config_southamerica/sgen3sis.rds\")) names(sim)    #### Visualize ---------------  #the outputs plot_summary(sim)  # using raster package plot(rasterFromXYZ(sim$summary$`richness-final`))  plot(rasterFromXYZ(sim$summary$`richness-final`), col=gen3sis::color_richness(10))}\n{r} # plot diversity at 3 time slices timesteps &lt;- c(20, 10, 0) par(mfrow = c(1, 3)) for (i in timesteps) {   landscape_i &lt;- readRDS(file.path(output_dir, paste0(\"config_southamerica/landscapes/landscape_t_\",                                                      i, \".rds\")))   species_i &lt;- readRDS(file.path(output_dir, paste0(\"config_southamerica/species/species_t_\",                                                    i, \".rds\")))   plot_richness(species_i, landscape_i) } #dev.off()}",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Day2_Prac3_Outputs</span>"
    ]
  },
  {
    "objectID": "Day1_Prac1_setup.html",
    "href": "Day1_Prac1_setup.html",
    "title": "2¬† Installation and set up",
    "section": "",
    "text": "The first bottleneck for any workshop is getting the software installed and running on everyone‚Äôs machine. So we‚Äôll spend a few minutes here making sure we‚Äôre all good with installing and taking a look at some of teh data we‚Äôll be working with during the workshop, before moving on to the nitty gritty. So, lets start by installing the Gen3sis R package.\nYou can install the package directly from CRAN as follows.\n\ninstall.packages(\"gen3sis\")\npackageVersion(\"gen3sis\")\n\nToday we‚Äôll install the most recent version of the package from GitHub using devtools.\n\ninstall.packages(\"devtools\")\ndevtools::install_github(repo = \"project-gen3sis/R-package\", dependencies = TRUE)\n\n\nlibrary(gen3sis)\npackageVersion(\"gen3sis\")\n\nAll the data for the workshop is stored in the ‚Äòdata‚Äô folder.\n\ndata_dir &lt;- \"data\"\n\nIn this fodler we include a paleoenvironmental reconstruction of South American temperature and aridity at a coarse spatial resolution of 2 degrees, and at a temporal resolution of 1 million years. Load it in and investigate some of it‚Äôs features.\n\n# read the R data file\nlandscape &lt;- readRDS(file.path(data_dir,\"landscapes\", \"SA_coarse\", \"landscapes.rds\"))\n\n# class\nclass(landscape)\n\n# names\nnames(landscape)\n\n# dimensions\ndim(landscape$temp)\n\n# take a look at first elements\nlandscape$temp[1:10, 1:10]\n\n# column names\ncolnames(landscape$temp)\n\nCoolies. We can use different spatial R packages to play with our data, and later on, with our simulated output. Parts of gen3sis package use raster, however this package is now depreciated, so we‚Äôll use terra except where stated. Ideally, you‚Äôll install both.\n\ninstall.packages(\"terra\")\ninstall.packages(\"raster\")\n\n\nlibrary(terra)\n\n# Present Day South America\nSA_1 &lt;- rast(landscape$temp[ ,c(\"x\", \"y\", \"1\")])\nSA_65 &lt;- rast(landscape$temp[,c(\"x\", \"y\", \"65\")])\n\n# plot present day\nplot(SA_1)\n\n\n# plot 65 Million years ago\nplot(SA_65)\n\nLets overlay the maps to get an idea of how much South America has changed since the dinosaurs went extinct.\n\n# overlay\nplot(SA_65, col=rgb(1,0,0))\nplot(SA_1, col=rgb(0,0,1,0.5,1), add=T)\n\nLoad in a config file containing the rules and parameters of a single simulation. We‚Äôll get into what this all means next chapter.\n\nconfig_dir &lt;- \"configs/SouthAmerica\"\nconfig &lt;- create_input_config(config_file = file.path(config_dir, \"config_southamerica_Day1Prac1.R\"))\nnames(config$gen3sis)\nnames(config$gen3sis$general)\n\nNow time to run a simulation in South America. We‚Äôll just run from 20 million years ago to the present-day at 1 million year intervals so it runs quick enough to finish in a couple of minutes. Note the output as it runs. Think about what its printing.\n\nsim &lt;- run_simulation(config = file.path(config_dir, \"config_southamerica_Day1Prac1.R\"), \n               landscape = file.path(data_dir,\"landscapes\", \"SA_coarse\"),\n               output_directory = \"output/SouthAmerica\",\n               verbose=1)\n\nIf you‚Äôve made it this far, great! You‚Äôre equipped with the tools, now we‚Äôre ready to explore how Gen3sis works in more detail.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Installation and set up</span>"
    ]
  },
  {
    "objectID": "Day1_Prac2_basics.html",
    "href": "Day1_Prac2_basics.html",
    "title": "3¬† Config Basics",
    "section": "",
    "text": "To begin the dive into what Gen3sis is, and how it operates, we‚Äôll start by looking a config file. The config is the code for the ecological and evolutionary rules and other parameters of Gen3sis, such as the random see, instructions on saving output, etc.\nA config file is a a stand-alone R script which is modified by you. We can generate a new blank config file automatically to specified location in your configs folder and open it in R. Give that try.\n\nwrite_config_skeleton(\"configs/blank_config\")\n\nOnce you‚Äôve got the hang of Gen3sis it‚Äôs straightforward to populate these with functions. However, for now, lets start with the config we used in the previous section. We should still have that config loaded in our workspaces, but if not run this code.\n\nconfig &lt;- create_input_config(config_file = \"configs/config_southamerica_Day1_Prac1.R\")\n\nlets take a look at the config\n\nconfig\n\nOh boy, that‚Äôs intimidating. But, don‚Äôt stress, we‚Äôll go through it piece by piece and learn what each bit is doing.\n\nstr(config)\nnames(config)\n\nWe can see that the config is a list with 3 components: 1. gen3sis, 2. user, 3. directories. For now, we‚Äôll focus on gen3sis which is the meat of the config. This ‚Äògen3sis‚Äô element itself is a list of 6 elements: ‚Äògeneral‚Äô, ‚Äòinitialization‚Äô, ‚Äòdispersal‚Äô, ‚Äòspeciation‚Äô,‚Äòmutation‚Äô, and ‚Äòecology‚Äô.\n\nnames(config$gen3sis)\n\n\nGeneral\nThe first element, ‚Äògeneral‚Äô, sets up some important global parameters of the model\n\nconfig$gen3sis$general\n\nThe random seed determines the starting point for random number generators in R. Because the simulations have stochastic processes, to reproduce a result, we need to have the same random seed, so by fixing it in a simulation, we can ensure we will get the exact same results next time we run the sim. Let‚Äôs change the seed to 777.\n\nconfig$gen3sis$general$random_seed\n\nconfig$gen3sis$general$random_seed &lt;- 777\n\nThe start time is the time-step of the landscape file which the simulation will start at. We saw in the previous chapter that the South American landscape file had 65 time-steps, but we actually only started our simulation at time-step 20, or 20 time-steps before the final one. Each time-step in the landscape is 1 million years apart, so the timestep 20 is 20 million years ago. However, if the landscape units were in 100 thousand years, then time-step 20 would be 2 million years ago. Let‚Äôs run the next simulation from an older timepoint, lets say the start of the Oligocene, 34 Ma.\n\nconfig$gen3sis$general$start_time\n\nconfig$gen3sis$general$start_time &lt;- 34\n\nOur simulation ran from 20 Ma to the present-day. However, we may wish for the simulation to finish before the present-day, for example just the Oligocene period 34Ma - 23Ma. To do this we can change the ‚Äòend_time‚Äô. When left as NA, the simulation will run to the final time-step. So let‚Äôs change that to 23 Ma.\n\nconfig$gen3sis$general$end_time\n\nconfig$gen3sis$general$end_time &lt;- 23\n\nOther general settings include setting the maximum number of species in simulation, and in each grid cell before the simulation terminates (max_number_of_species, max_number_of_coexisting_species) which is a good way of aborting simulations before they get unwieldy, the names of the traits that each species will have in the simulation (trait_names), and the range of the environmental data (environmental_ranges). We‚Äôll these as is for now.\n\nconfig$gen3sis$general$max_number_of_species\n\nconfig$gen3sis$general$max_number_of_coexisting_species\n\nconfig$gen3sis$general$trait_names\n\nconfig$gen3sis$general$environmental_ranges\n\nLast but not least in the general setting is the oberserver function. At each time step in the simulation, users have the option to save different outputs and make different plots. The species object contains a list, where each element is a species. The species has information on the occupancy, abundance, and trait values of populations of that species in all inhabited grid cells. The phylogeny object contains information on the relatedness of all species to each other.\nMost of the biodiversity infromation we simulate is contained in species objects and phylogeny objects so we will save these at each timestep. We will also plot species richness as a way of visualizing how the simulation proceeds.\n\nconfig$gen3sis$general$end_of_timestep_observer = function(data, vars, config){\n    save_species()\n    save_phylogeny()\n  \n  # plotting function example:\n    plot_richness(data$all_species, data$landscape)\n}\n\n\n\nInitialization\nInitialization lets us define the number, abundance, location, and traits of the ancestral species. This is what you start the simulation with. You may want to start with a single species, so the simulation follows the diversification of single monophyletic radiation. Alternatively, you may seed the landscape with many species and this is also possible. Each species must be given the locations in which they will occur, in the form of characters matching the grid cell identifiers, and values for the traits we named in the general settings.\n\nconfig$gen3sis$initialization\n\nIn this example, we are generating five species to begin. We first define a box from which we sample points to use to place the first species on the landscape. We randomly sample a single grid cell to place each initial species in. Next, we give each initial species values for the three traits. Here, we give the value for temp as the temperature value of the grid cell the species will occur in. We set a dispersal equal to 1. We repeat this 5 times, for 5 species. We can create more ancestor species by repeating this process in a loop , or we could manually create ancestral range by hand-selecting grid cells for the species to occur in.\n\n\nDispersal (migration)\nHow species disperse across the landscape is determined by simulated migration events between habitable cells. The range and behaviour of these events is set by users and can be based on fixed values, draws from probability distributions, species trait values, or anything else thought up by users.\n\nconfig$gen3sis$dispersal\n\nHere we set the maximum dispersal distance as infinty (e.g., no maximum), and we draw the dispersal values from a Weibull distribution with shape parameter = 1.5 and scale = 133. We can see what this distribution looks like by plotting a histogram.\n\nhist(rweibull(1000, 1.5, 133), main= \"Weibull Distribution 1\", xlab=\"Dispersal Distance (km)\")\n\nYou can see the dispersal kernel is skewed around the scale parameter (here scale =133), so most dispersal is over shorter distances but some dispersal will be over a longer distance. You can play with the parameters to change the dispersal kernel. These could be based on a trait of the species.\n\n#more skewed distribution\nhist(rweibull(1000, 0.5, 133), main= \"Weibull Distribution 2\", xlab=\"Dispersal Distance (km)\")\n\n\n#less skewed distribution\nhist(rweibull(1000, 3, 133), main= \"Weibull Distribution 2\", xlab=\"Dispersal Distance (km)\")\n\n\n\nSpeciation (population divergence)\nIn the speciation function, we determine how populations diverge from one another and when they are sufficiently divergent to become new species. Populations that are geographically isolated (allopatric) diverge at each time step by the divergence factor and are considered new species when the accumulated divergence is greater than the divergence threshold. Divergence decreases when they come back into secondary contact at a rate of 1 and will coalesce into the same population once divergence is equal to 0.\n\nconfig$gen3sis$speciation\n\nIn this example, the get_divergence_funtion returns a value of 1 each timestep, so the divergence accumulates by a value of 1 at each time step and populations become new species when divergence is greater than the divergence threshold, here given a value of 2. So a new species can form if two populations has been isolated for two timesteps.\nWe can change either the amount of divergence required for speciation‚Ä¶\n\nconfig$gen3sis$speciation$divergence_threshold &lt;- 4\n\n‚Ä¶or the rate at which divergence accumulates.\n\nconfig$gen3sis$speciation$get_divergence_factor &lt;- function(species, cluster_indices, landscape, config) { return(2)}\n\nBoth of these will speed up the rate of speciation, given enough population fragmentation.\n\n\nMutation (trait evolution)\nIn the evolution function, we determine how the species‚Äô traits change at each timestep and therefore how they evolve over time. In gen3sis, each species is comprised of separate populations in each inhabited grid cell, these populations form geographic clusters that are within dispersal distance of one another and could be considered to exchange individuals, and all geographic clusters together comprise the species.\nWe can evolve traits of each population independently. Alternatively, we could give all populations within a geographic cluster shared trait values and evolve traits at this level of organization, or again at the whole species level. At which level of biological organization you evolve traits will depend on your hypothesis and the system you are trying to represent.\nIn addition to mutating the traits of species, we might also want to homogenise traits of populations that are likely exchanging gene flow.\nThis example, highlights both homogenising traits and evolving traits.\n\nconfig$gen3sis$mutation\n\nHomogensation assigns each geographic cluster the avaerage trait value weighted by the abundance of each population. Here larger populations contribute more than smaller populations to the avergae.\nAfter homogenisation, the trait evolves by drawing random values from a normal distribution and adding these to the traits. A mean of 0 ensures that positive trait changes and negative trait changes are equally likely. The trait_evolutionary_power variable detemines the degree of trait evolution, with higher values leading to higher average trait changes each time step. This process of adding a random normal variable approximates a Brownian motion model of trait evolution.\n\n\nEcology (interactions)\nEvery species present in a cell across the landscape has an abundance value representing the population size of the species in that location. The ecology function allows users to modify this abundance value based on environmental values, species interactions, or anything else relevant to the study. An abundance of 0 leads to the extinction of the species in that cell.\n\nconfig$gen3sis$ecology\n\nHere we use the temp trait (temperature niche position) and temp_breadth (temperature niche breadth) to determine whether a population can survive in cell. We get the absolute difference between the niche position and the temperature value in the grid cell. We then ask if this difference is more than the niche breadth. If it is larger, this means the value of the grid cell is outside the population‚Äôs niche breadth and it goes extinct in that grid cell. Extinction is indicated by giving the abundance a value of 0 or setting the abundance to FALSE as done here.\nOK, that gives you the basic overview of all the main components of the gen3sis model. We will now move on to running some simulations on an island case study. But before we do, we may want to save any changes we made to the config for later. To do this use the following code.\n\n# Oskar",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Config Basics</span>"
    ]
  },
  {
    "objectID": "Day1_Prac3_islands.html",
    "href": "Day1_Prac3_islands.html",
    "title": "4¬† Day 1 - Prac 3 - Islands",
    "section": "",
    "text": "This practical uses a theoretical archipelago system. Each site (1x1 km), features temperature (i.e.¬†mean, minimum and maximum temperature) and has a landscape structure that is generated by approximating topography, uplift dynamics, and a lapse rate of temperature with elevation. Additionally, it incorporates global temperature and sea level changes dating back to the past 5 million years (Ma).\nYou can look at an animation of the landscape here. We‚Äôll also have a look now.\n\n5 Dynamic Island Landscape\n\n# libraries\nlibrary(gen3sis)\nlibrary(terra)\n# load landscapes\nlc &lt;- readRDS(file.path(\"data\", \"landscapes\", \"islands\",\"landscapes.rds\"))\n\n# class(lc) \"list\"\n\n# get names of landscape variables\n\nnames(lc)\n\n# get first time step\n\nfirst_step_pos &lt;- ncol(lc$mean_temp)\n\n# get first 10 sites of mean temperature for the 2 last time steps and the first (oldest) time step\n\nlc$mean_temp[100:110, c(1:4, first_step_pos)]\n\n# plot mean_temp for first and last time step\n\nplot(rast(lc$mean_temp[ ,c(1:3, first_step_pos)]))\n\nPlot out the landscape to understand it‚Äôs dynamics. First define the function.\n\nplot_landenv &lt;-  function(df, times=100:0, reverse=F, speed=0.1){\n  # df is a data frame with x, y coordinates and time steps as columns with environmental variables\n  # reverse is a boolean. Reverse the order of time steps?\n  # times is either a vector of time steps or a character \"all\"\n  # speed in seconds\n  #df &lt;- lc$temp\n  if (times[1]==\"all\"){\n   times &lt;- names(df)[!names(df)%in%c(\"x\", \"y\")] \n  }\n  if (reverse){\n    times &lt;- rev(times)\n  }\n  for (ti in times){\n    ri &lt;- rast(df[,c(\"x\", \"y\", ti)], type=\"xyz\")\n    plot(ri, main=paste(as.numeric(ti)/100, \"Ma\"))\n    Sys.sleep(speed)\n  }\n}\n\nThen run the animation function\n\nplot_landenv(lc$elevation, times=seq(from=1, to=500, by=50), speed=0.1)\n\nload in a config\n\n# load config\ncf &lt;- create_input_config(config_file = \"configs/config_islands_simple_Day1Prac3.R\")\n# list all main elements of the config file\nnames(cf$gen3sis)\n# list all elements of the general section, i.e. the main settings and not so much on the eco-evolutionary processes\nnames(cf$gen3sis$general)\n\n\n\n6 Run a basic simulation\n\n# run simulation\nsim &lt;- run_simulation(config = \"configs/config_islands_simple_Day1Prac3.R\", \n                      landscape = \"data/landscapes/islands\", \n                      output_directory = \"output/islands\")\n\n\nsim &lt;- readRDS(\"output/islands/config_islands_simple_Day1Prac3/sgen3sis.rds\")\n\n\n#check elements inside the sim object\nnames(sim)\n\n# visualize the outputs\nplot_summary(sim)\n\n# plot richness from summary in custom fashion\nna_mask &lt;- is.na(lc$elevation[,\"0\"])\nrich &lt;- sim$summary$`richness-final`\nrich[na_mask,3] &lt;- NA\nplot(rast(rich, type=\"xyz\"), main=\"Richness\")\n\n\n# plot richness at time step 32 using saved data\nsps32 &lt;- readRDS(here(\"output/config_islands_simple_Day1Prac3/species/species_t_32.rds\"))\nlc32 &lt;- readRDS(here(\"output/config_islands_simple_Day1Prac3/landscapes/landscape_t_32.rds\"))\nplot_richness(sps32, lc32)\n\n\nphy &lt;- read.nexus(file.path(here(\"output/config_simple/phy.nex\")))\nplot(phy)\n\n\n\n7 Customize simulations\nFor an example of a more complex simulation, with species abundances, traits trading off and evolving check the config_M2_TH.R.\nWe will modify it so that allopatric speciation is faster.\n```{r, eval=FALSE}\nconf &lt;- create_input_config(here(‚Äúconfig/config_M2_TH.R‚Äù))\nconf$gen3sis$speciation$divergence_threshold = 30\n```\nWe will also change the observer function to save the presence/absence matrix for each time step.\n```{r, eval=FALSE}\nconf$gen3sis$general$end_of_timestep_observer = function(data, vars, config){\nplot_richness(data$all_species, data$landscape)\n# make p/a matrices\nout_dir &lt;- config$directories$output\nif(!file.exists(file.path(out_dir,‚Äúoccs‚Äù))){\ndir.create(file.path(out_dir, ‚Äúoccs‚Äù))\n}\n# cell names\nall_cells &lt;- rownames(data$landscape$coordinates)\n# get 0 for absence and 1 for presence in each grid cell\nasp &lt;- do.call(cbind,\nlapply(data$all_species, FUN = function(x) {\nifelse(all_cells %in% names(x$abundance), 1, 0)\n}))\n# colnames are species names\ncolnames(asp ) &lt;- unlist(lapply(data$all_species, function(x){x$id}))\n# column bind with x/y coordinates\npresence_absence_matrix &lt;- cbind(data$landscape$coordinates, asp)\nsaveRDS(presence_absence_matrix,\nfile=file.path(out_dir,‚Äúoccs‚Äù, paste0(‚Äúpa_t_‚Äù,vars$ti, ‚Äú.rds‚Äù)))\n}\n```\n```{r, eval=FALSE}\nsimod &lt;- run_simulation(config=conf,\nlandscape=here(‚Äúspace‚Äù),\noutput_directory=tempdir())\n```\nThe dynamics is different from the simple simulation, with more species and a some extinction events.\n```{r, echo=FALSE}\nplot_summary(readRDS(here(‚Äúoutput/config_M2_TH_mod/sgen3sis.rds‚Äù)))\nplot(read.nexus(file.path(here(‚Äúoutput/config_M2_TH_mod/phy.nex‚Äù))))\n```\n&lt;div style=‚Äúbackground-color: lightgreen; padding: 1px;‚Äù&gt;\nüèãüíª **Exercise** [15 min]\nReview the config_M2_TH.R file and try to understand what it‚Äôs doing. Consider how you might modify the configuration or apply it to a specific research question.\n&lt;/div&gt;\n## 5. Troubleshoot\nCreating or modifying a gen3sis configuration can definitely lead to some weird errors, especially since it‚Äôs so flexible. That‚Äôs the downside, along with the steep learning curve. But if you‚Äôre not too overwhelmed, you‚Äôre doing great!\nHere are some handy debugging tips for when you run into those pesky errors:\nbrowser(): This function lets you pause the execution and explore what‚Äôs going on. It‚Äôs like a pit stop where you can check out variables and step through the code.\nTo make your R session enter browser mode whenever you hit an error, you can use: *options(error = recover)*. This will help you diagnose and fix issues more easily.\nYou can also condition browser calls, which is very useful when you want to stop execution at a specific time step or when a certain condition is met. Here‚Äôs an example:\n```{r, eval=FALSE}\n# Use ‚Äòstop_time‚Äô to halt execution at a specific timestep in the landscape object:\nstop_time &lt;- ‚Äú62‚Äù\nget_dispersal_values &lt;- function(n, species, landscape, config) {\nif (landscape$timestep == stop_time) {\nbrowser()\n}\n# You can also check the ‚Äòvars‚Äô object for the current timestep:\nvars &lt;- dynGet(‚Äúvars‚Äù, inherits = TRUE)\nif (vars$ti == stop_time) {\nbrowser()\n}\n}\n```",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Day 1 - Prac 3 - Islands</span>"
    ]
  }
]